## Web Scalability for startup engineers
这本书中文是《互联网创业核心技术 - 构建可伸缩的WEB应用》，名称过于夸大。
- Scalability中文翻译为伸缩性、规模扩展性。注意不要跟弹性（elasticity）混淆
- 中文版翻译的也有问题，有些句子从原文的“应该是xx”翻译成“是xx”，含义变化很大
- 有些地方使用“架构”一词，有时实际上应该是基础设施（infrastructure）

### Chapter 1 Core Concepts
伸缩性度量
- 处理更多数据
- 处理更高并发
- 处理更高频次的用户请求

- scale up (Scalability Vertically）:
    - 基本不需要调整代码
    - RAID是一种scale up方案
    - 越过某个点后，成本会增长很快。
    - 有极限值。业务上的部分依赖锁的串行性也限制了可scale的程度
- 服务隔离（Isolation of Services）
    - 模块化、功能分割（functional partitioning)
- CDN
- Horizontal Scalability: distribute the traffic
    - 克服 scale up的成本、极限值等限制
    - 需要调整应用架构，相对困难
- Scalability for a Global Audience
    - GeoDNS、edge-cache
- Web Application Layer
    - 生成页面、最小的业务逻辑，业务逻辑放在服务层，因为变更频繁
    - 这一层应该设计为完全无状态的，所以可比较方便的进行scale
- Web Services Layer
    - 实现大部分的业务逻辑，更易于做functional partitioning
    - 只要尽量是stateless，就很容易scale
- Data Persistence Layer
    - 最难以进行水平scale的
    - 包括搜索服务、数据存储服务

Architecture should evolve around the `business model`. ..domain-driven design and software architecture...best practices of software design. To follow these best practices, we put `business logic` in the center of our architecture. It is the business requirements that drive every other decision. Without the `right model` and the `right business logic`, our databases, message queues, and web frameworks are useless. 或使用`domain model`

Overview of the Application Architecture
- Front end
    - core business logic 无关的，页面、展示等
    - 这一层禁止访问数据库和其他三方服务，否则影响代码复用、提高复杂度
- Web services
- Supportting Technologies

Architteture Style
- SOA
- layered architecture
- hexagonal architecture, 六角架构
- event-driven architecture.

Remember, the `data store` is not the central piece of the architecture, and it should not dictate the way your system evolves.

`Architecture` is the perspective of the software designer; `infrastructure` is the perspective of the system engineer. Each perspective shows a diﬀerent view of the same problem — `building scalable software`. 这里将`Architecture`跟`infrastructure`做了拆分，这样从不同角度来理解可伸缩软件，但中文里，基本上统称架构，画图时常混在一起，在国内职位划分上也没有专门的`system engineer`，这俩个是合一的。

### Chapter 2 - Principles of good software design
- Simplicity
    - Hide Complexity and Build Abstractions
    - Avoid Overengineering(过度设计)
    - Try Test-Driven Development：先写测试代码，强制从用户视角看问题
    - Learn from Models of Simplicity in Software Design：Grails、Hadoop、Google Maps API
- Loose Coupling
    - 低耦合保证复杂性局部化
    - 封装可减少耦合和促进简化
    - 在满足需求的情况下，尽量少暴露内部细节
    - 解耦和过度设计的平衡
    - 避免不必要的耦合：getter/setter不需要的就别添加
    - 良好设计的模块架构图应该是一棵树，而非一个图
    - 好的低耦合示例：UNIX文件操作和PIPE、SLF4J
    - Knowing things about the service implies coupling, the more you need to know about a component, the stronger is your coupling to it.
- Don't repeat yourself(DRY)
- Coding to contract: 基于约定／interface编程
    - protocols
- Draw diagrams
    - 用例图、类图、模块图
- Single responsibility
- Open-closed principle（开闭原则）
    - Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
    - The `interfaces` are `closed for modifications`, and you can provide new implementations to extend the functionality of your software.
    - 比如java排序的Comparator、依赖注入
- Dependency injection
    - 类无需知道自己的依赖什么时候创建、注入
- Inversion of Control(IoC)
    - 好莱坞原则：不要给我们打电话，我们会给你打电话
    - 类，不需要知道自己什么时候被创建、被谁使用
- Designing for scale
    - scalability方法基本是下面三类
        - Adding more clones（增加副本）: Adding indistinguishable components
            - 对于无状态服务，该方法很简单，对于有状态的服务需要注意如何存储状态，副本间如何同步状态
        - Functional partitioning（功能分割）: Dividing the system into smaller subsystems based on functionality
            - 纵横向拆分为独立的子系统，甚至是独立自给自足的应用
            - 分割后增加管理上的困难；有分割极限
        - Data partitioning（数据分割／分片）: Keeping a subset of the data on each machine
            - 每个服务器的数据相互独立：按key hash划分cache位置
- Design for self-healing：高可用和自愈
    - fall over(失效转移)
    - 高可用的主要方式：removing single points of failure and graceful failover. 消除单点失效（通过冗余）、失效转移
    - 自愈系统：自动检测自己的部分失效，并能尽快自动修复

### Chapter 3 - Building the front-end layer
Most of today’s websites are built as
- traditional multipage web applications
- single-page applications (SPAs)
    - Tese execute the most business logic in the browser, more so than either hybrid or traditional applications. Tese applications are built mainly in JavaScript, with web servers often reduced to providing a data application programming interface (API) and a security layer.
- hybrids of these two approaches.

1. Managing State
- Managing HTTP Session(cookie实现)
    - 实现HTTP会话 stateless
        - Store session state in cookies
        - Delegate the session storage to an external data store
        - Use a load balancer that supports sticky sessions：这种方案打破了statelessness原则，会把session信息绑定在一台机器上
- Managing Files
    - two types of file
        - User-generated content being uploaded to your servers
        - Files generated by your system that need to be downloaded by the user
    - 公开访问的文件可存放在CDN，私有的照片一般没必要
    - 分布式文件存储是一个复杂的问题，可能的话尽可能使用三方服务，快速搭建应用，降低成本
- Managing Other Types of State
    - local server cache, application in-memory state, and resource locks
    - 将全局需要的功能和状态从应用中隔离出来成为一个服务，会增加延迟、管理维护复杂度
    - Zookeeper，Curator、存储系统的某个原子操作（NoSQL，MySQL、PG）

保证服务器无状态能更好的实现scale

Components of the Scalable Front End
- DNS：可使用三方服务
- Load Balancers
    - 优势
        - Hidden server maintenance
        - Seamlessly increase capacity
        - Efficient failure management
        - Automated scaling
        - Eﬀective resource management: SSL offloading，data center内部不需要SSL
    - 可使用云厂商提供的负载均衡、软件实现的自管理负载均衡（Nginx、HAProxy）、Hardware Load Balancer
    - 负载均衡本身没什么状态，很容易水平伸缩，但需要注意配置同步问题
    - 负载均衡服务器上无业务逻辑，不会频繁升级，很少会因为bug而失效
    - 负载均衡服务器本身的均衡可通过DNS轮询方式
    - Hardware Load Balancer：F5的Big-IP，Citrix的Netscalar
    - load balancer as a service可能是为来的一个方向
- Web Servers
    - Because the front end is mainly about handling user interactions, rendering views, and processing user input, it makes sense to use technologies that are good at these tasks. I would recommend dynamic languages like PHP, Python, Groovy, Ruby, or even JavaScript (Node.js) for the front-end web application development, rather than using pure Java or C or a constraining framework like Java EE, JSF, or CGI.
- Caching
    - Caching is one of the most important techniques when it comes to scaling the front end of your web application.
    - CDN、缓存在浏览器、无法缓存在前两者的可用object cache（Redis等）
- Auto-Scaling
    - 一般云厂商有auto-scaling as a service


I strongly recommend using `load balancers` as the entry point to your data center, as they will allow you to scale more easily and make changes to your infrastructure without negatively aﬀecting your customers。

虽然云能提供可伸缩、易部署和支持快速开发的服务，但是自购硬件也有好处
- 对延迟和吞吐有更好的把控
- 物理机要比虚拟机性能要好
- 管理的服务器数量上去后，自购服务器就比租云服务相对便宜了，且使用自购硬件，垂直伸缩更高效
- 安全、法律限制，只能自购硬件

### Chapter 4 - Web Services
1. Designing Web Services
diﬀerent ways of designing APIs
- Web Services as an Alternative Presentation Layer
    - 展示层和服务层没有分离开，事实上也没有一个明确的服务层
    - 轻量、简单，适合在不确定业务模型时、创业早期阶段
    - 不是每个应用都需要API，每个web应用都设计为web服务也许是一种不必要的过度设计
    - 不便于scale、长期维护
- API-First Approach
    - 说起来容易做起来难，既要避免过度设计，又要提供全部所需功能，总会出现有的地方设计过多，有些地方考虑不周
    - 更适合成熟的系统和应用
- Pragmatic Approach（务实）
    - 一开始就考虑web service，但仅在必要时实现
    - 绝大多数创业点子其实都是伪需求，等开发出来发现客户根本没兴趣。最好的方式快速搞个原型出来验证下，而不是深入到什么设计、建模、开发web服务等细节中
    - 一旦有了付费客户基础，最好用API优先的方式

2. Types of Web Services
- Function-Centric Services
    - CORBA、XML-RPC、DCOM、SOAP（the dominant technology）
    - SOAP：Being `able to discover services` and `define explicit contracts` are great parts of SOAP, and I wish I could easily build SOAP services. Unfortunately, the lack of tooling and libraries for dynamic languages makes it impractical to build SOAP services in these technologies.
    - SOAP scale差，已不再是web服务开发的主流技术，开发复杂性和维护工作量大。如果是企业应用如银行保险，则比较合适
- Resource-Centric Services
    - `REST`(Representational state transfer)是一个面向资源的架构风格。使用GET／PUT/POST/DELETE不一定要用JSON，但目前已经是事实上的标准
    - 使用WEB服务前先进行服务验证（通常使用OAuth 2），然后每次请求带上认证令牌
    - `REST`请求唯一需要的是URL，便于客户端和服务端缓存

3. Scaling REST Web Services
- Keeping Service Machines Stateless：流量分派、宕机剔除、重启下线、服务更新高可用
    - 只有一类状态存放在web服务上是安全的：缓存。根据缓存的定义，缓存数据是可丢失的，也可以在任何适合重建，所以服务器宕机不会引起数据丢失
    - 有时构建web服务时，一些场景需要共享状态，如认证令牌、资源锁（尽量避免）
    - 应用级别的事务：两阶段提交2PC。影响scalable和availibility，尽量减少使用，用其他方式替代，如补偿事务机制（`compensating transaction`），此时`coordinating web service`需要保证数据一致性
- Caching Service Responses
    - 确保GET 请求是只读的。本地缓存、身份认证
    - 反向代理层实现http层缓存
- Functional Partitioning
    - 功能分割太早、划分粒度太细的主要挑战是新的需求不断出现，需合并多个web服务的数据和功能，这比访问一个数据存储一个代码库工作量要大

### Chapter 5 - Data Layer
1. Scaling with MySQL
MySQL scale的主要手段：复制（`replication`），对于MySQL就是主从复制

读写分离，一写多读，同时也提高了读的可用性

两种失效场景
- 主服务器失效
    - MySQL不支持自动失效转移和提升从为主
    - 主-主模式（多主模式），复杂，数据不一致风险较高，如自增列的值在两侧的差异
        - 能提高availibility但无法提高scalability
        - Both masters have to perform all the writes.
        - Both masters have the same data set size.
- 从服务器失效
    - 可很快修复

replication对分摊写负载压力没什么帮助，对分摊读操作压力很有用（主服务器的复制数量优先，可分级复制），还可将不同的读操作分散到不同的从服务器

It is important to think about your `data access patterns` and the `active data set size`, because having too much active data is a common source of scalability issues.

主从复制的延迟、读写请求的时间差、不同服务器的处理时差、都会影响应用是否能及时读取到最新的数据。如更新表结构可能会将复制过程卡住较长时间。

不理解MySQL复制的复杂性和各种代价可能是致命的，如复制差错，导致在主服务器上正常，从服务器失败，不好debug

Data Partitioning (Sharding)：将数据切分为互不关联的子集
- 数据分片放在不同的服务器上，服务器间相互独立，不共享信息
- 选择恰当的sharding 键，如用户id，sharding可以在应用层做，基于某种方式shard并路由到对应数据库
- sharding是尽可能分成更小的片，放在更多的分区中
- 跨分片数据查询很麻烦、无法使用ACID事务
- 增加服务器需要迁移大量数据，增加后key与分片对应关系问题（可用单独服务器存储）
- 一种简单的分片方案：创建N个database，每个database内表结构相同(阿里的cobar)
- 应用级分片面临的另一个问题是不易生成唯一标识符，可使用自增列+offset

2. Scaling with NoSQL
NoSQL made signifcant tradeoﬀs to support this scalability. 所以对NoSQL选型时要考虑需要的最重要的特性，考察NoSQL的哪些特性被牺牲掉了

CAP原理并不完全正确，但是给出了信号：scalable data stores require tradeoﬀs

Eventual Consistency：可能导致数据冲突，最终写入“赢”，让客户端解决冲突

投票一致性（至少等几个服务器返回成功才算成功）

Cassandra是真正的水平伸缩数据存储系统。删除和更新代价很高

虽然大多数NoSQL数据存储系统很容易上手，但是想要自如的使用还是需要很多的经验，系统内部的结构也可能和期望的不一样。

### Chapter 6 - Caching
影响缓存命中率的三个主要因素
- `data set size`(the size of your cache key space)
    - The fewer cache keys possible, the better for your cache efciency.
- `space`(the number of items that you can store in your cache before running out of space.)
    - The more objects you can physically ft into your cache, the better your cache hit ratio.
- `longevity`(how long, on average, each object can be stored in cache before expiring or being invalidated.)
    -  Simply put, the longer you can cache your objects for, the higher the chance of reusing each cached object.

#### Caching Based on HTTP
all of the caching technologies working in the HTTP layer work as `read-through caches`（通读缓存）. Since the interface of the `service` and the `read-through cache` are the same, clients can connect to the service directly, bypassing the cache, as `read-through cache only works when you connect through it`...transparent to the client. 可拔插

You can always put an `HTTP cache` between your `web service` and your `clients` and leverage the same caching mechanisms that you use for your `web pages`.

- Cache-Control
- Expires
- Vary: 基于某个请求头，生成响应的多个变体，如基于Accept-Encoding，压缩和非压缩两种

场景1: 允许客户端永久缓存响应，常用到静态内容上。此时静态内容不可变，新发布时可更改其URL。该方法有如下好处：客户端永久缓存响应；客户端可访问同一文件的多个版本。这样可使缓存命中率最大化并让新代码更容易部署，使用同一文件多个版本，也避免版本兼容问题，如老页面加载新js脚本出差，新页面加载老js脚本等

场景2: 响应不被缓存。设置对应的no-cache HTTP header即可

场景3: 私有缓存

Types of HTTP Cache Technologies
- browser cache
- caching proxies
    - ISP提供
- reverse proxies
- CDNs
    - 专门的CDN厂商提供，跟ISP类似

#### Caching Application Objects
After HTTP-based caches, the second most important caching component in a web application stack is usually a `custom object cache`. `Object caches` are used in a diﬀerent way than `HTTP caches` because they are `cache-aside`（旁路缓存） rather than read-through caches.

- Client side cache：`web storage`
- Caches Co-located with Code
    - 方式
        - Objects are cached directly in the application’s memory.
        - Objects are stored in shared memory segments so that multiple processes running on the same machine could access them.
        - A caching server is deployed on each web server as a separate application.
    - 限制
        - 各web server重复缓存
        - 缓存一致性
- Distributed Object Caches

Scaling Object Caches
- data partitioning
    - 一致性hash(hash环），伸缩时只有一部分键需要调整，对缓存命中影响较小
- data replication：cache的只读服务器

#### Caching Rules of Thumb
- Cache High Up the Call Stack
    - the higher up the call stack you can cache, the more resources you can save.
- Reuse Cache Among Users
    - when working with caching is to always try to reuse the same cached object for as many requests/users as you can.
- Where to Start Caching?
    - To prioritize what needs to be cached, use a simple metric of `aggregated time` spent generating a particular type of response. You can calculate the aggregated time spent in the following way: `aggregated time spent = time spent per request * number of requests`
- Cache Invalidation Is Diffcult
    - cache invalidation becomes difcult very quickly
    - Cache invalidation is difcult because cached objects are usually a result of computation that takes multiple data sources as its input. That, in turn, means that whenever any of these data sources changes, you should invalidate all of the cached objects that have used it as input. To make it even more difcult, each piece of content may have multiple representations, in which case all of them would have to be removed from cache.
    - 更好的失效策略是设置一个较短的TTL；对一致性要求高的场景，缓存大部分信息，但对于关键的内容通过数据存储获取
    - 缓存失效问题很难复现和调试，除非绝对必要，尽量不要去实现缓存失效算法，而使用上面提到的失效策略，一般都是能满足业务需求的。

### Chapter 7 - Asynchronous Processing
free-and-forget model, callbacks

#### Message Queues
- Message Producers
- Message Broker
- Message Consumer
- Messsage Protocols

`Message queues` are a great tool for achieving asynchronous processing and they can be used in applications that are built in a synchronous fashion. 就算应用或编程语言本身不支持异步, `you can use message queues to achieve asynchronous processing`.

A `message queue` is a component that buffers and distributes asynchronous requests.

分离生产者和消费者带来的好处：
- nonblocking communication between producer and consumer. decouping
- producers and consumers can be scaled separately。

生产者：Message producer or message publisher

A message queue can be implemented in many diﬀerent ways
- a shared folder with an application allowing you to read and write fles to and from it
- a component backed by a SQL database (as many homegrown message queues are)
- message broker(消息代理) that takes care of accepting, routing, persisting, and delivering messages

消息队列一般还有permissions control, routing, or failure recovery等功能，一般实现为独立的应用，称为`message broker`、`message-oriented middleware(MOM)`、`enterprise service bus (ESB)`

实现消费者的主要方式：
- `cron-like` 周期模式 拉模式
    - 适用于没有持久允许的应用容器的场景、消息较少或网络不稳定的场景
- `daemon-like` 守护进程模式
    - 无限循环方式，一般是长连接，block在message read上
    - 在有持久化应用容器的场景更常见

常见消息路由方法
- direct worker queue
    - 基于队列名称，每个message仅被消费一次（失败了如何处理？还是先mark后删消息）
- publish/subscribe
    - 消息发送到某个主题(topic)，可能会被多个消费者收到
    - 观察者模式的变体
- custom routing rules
    - 如基于log的文本匹配

开源产品常见的消息协议
- AMQP 业界标准，aimed at `enterprise integration` and `interoperability`
    - 如果可能，推荐使用
- STOMP 极简化的协议，无状态，基于文本
- JMS 纯java标准

消息工作者（消费者）尽量保持无状态，以获得更好的伸缩性

选择message broker前需要考虑的问题
- Number of messages published per second
- Average message size
- Number of messages consumed per second (this can be much higher than publishing rate, as multiple consumers may be subscribed to receive copies of the same message)
- Number of concurrent publishers
- Number of concurrent consumers
- If message persistence is needed (no message loss during message broker crash)
- If message acknowledgment is needed (no message loss during consumer crash)

#### Benefts of Message Queues
- Enabling asynchronous processing
    - Interacting with remote servers
    - Low-value processing in the critical path（关键业务）
    - Resource intensive work
    - Independent processing of high- and low-priority jobs
- Easier scalability
- Evening out trafc spikes
    - 同时提高了系统的可用性
- Isolating failures and self-healing
    - 消费者的更新也不影响生产者
- Decoupling

#### Message Queue–Related Challenges
使用消息队列和异步常见的调整
- no message ordering
    - 解决方法
        - Limit the number of consumers to a single thread per queue.
        - Build the system to assume that messages can arrive in random order
        - Use a messaging broker that supports partial message ordering guarantee.
            - 如ActiveMQ的message groups
- message requeueing
    - to depend on `at-least-once delivery` instead of `exactly-once delivery`.
    - 需要消费者支持幂等，某些场景下很困难或代价很大
    - 幂等操作对消息处理顺序更加敏感，如`set value = 10`与`set value = 20`，顺序不同结果不同
- race conditions
    - 主要由消息顺序问题导致
- increased complexity
    - 随着系统增长和消息代码的增加，厘清各部分依赖变得越来越困难
    - 让文档基于代码生成

#### Message Queue–Related Anti-Patterns
When the solution proves to be successful over and over again, we call it a `pattern`, but when the solution is repeatedly difcult to maintain or extend, we call it an `anti-pattern`. 典型的反模式是一开始开起来不错，用的越久就发现越多的问题。

- Treating the Message Queue as a TCP Socket
    - 一些消息队列允许消费者回发消息给生产者，增加耦合，两边相互影响
- Treating Message Queue as a Database
    - 允许随机访问、删除或更新消息。这会导致无法水平伸缩，或移植到其他的broker中
- Coupling Message Producers with Consumers
    - Treat the format of the message as a contract that both sides need to understand, and disallow any other type of coupling.
    - 比如把java序列化结果放进message，则消费者必须使用相同的类进行反序列化，而带来两者的依赖
- Lack of Poison Message Handling
    - Hope for the best, prepare for the worst
    - ActiveMQ可使用`dead-letter queue policies`: 失败特定次数后消息被删除

#### Quick Comparison of Selected Messaging Platforms
- Amazon Simple Queue Service (SQS)
    - 简单，按需付费，节省时间金钱成本
    - 相比后两者不够灵活，无法自定义路由规则。。。等
- RabbitMQ
    - 最初为金融机构设计的高性能消息队列平台
    - 可动态配置路由（常规的通过queue name或topic name来通信的，仍然通过该名称有一定耦合）
    - 不提供现成的水平伸缩
- ActiveMQ
    - java编写，可能会OOM而崩溃
    - 可通过Camel实现复杂的路由，Camel有点复杂
    - 实现了消息分组，确保部分消息有序传递
    - 不提供现成的水平伸缩

#### Introduction to Event-Driven Architecture (EDA)
- Request/Response Interaction
    - `Temporal coupling`（时间耦合） is another term for `synchronous invocation`
- Direct Worker Queue Interaction
    - 消息生产者基本上知道哪些消费者来处理，但contract上是decoped
    - 生产者消费者may not be coupled by the contract, but it is still coupled logically.
- Event-Based Interaction
    - 高度解耦，事件发布者不知道消费者
    - EDA可用消息队列来实现
    - 可水平伸缩

一种说法：EDA是架构设计，消息队列是实现设计

`Event sourcing`（事件溯源） is a technique where every change to the application state is persisted in the form of an event. 数据库的binlog类似

### Chapter 8 - Searching for Data
索引的重要属性
- An index is structured and sorted in a specifc way, optimized for particular types of searches.
- The data set is reduced in size because the index is much smaller in size than the overall body of text so that the index can be loaded and processed faster.

Considering that indexes add overhead, it is important to know what data is worth indexing and what is not. To make these decisions, you need to look at the `queries that you intend to perform on your data` and `the cardinality of each feld`.(基数，field的唯一址的个数，少的不大适合做索引，因为不能有效的缩小要比较的数据集合，比如性别)

Rules of thumb when creating indexes on a data set:
- the higher the cardinality, the better the index performance.
- equal distribution leads to better index performance(数据分布不均匀，比如按生日，则索引性能会急剧下降)

A `compound index`, also known as a `composite index`, is an index that contains more than one feld. You can use compound indexes to increase search effciency where cardinality or distribution of values of individual felds is not good enough.

#### Modeling Data
When you use NoSQL data stores, you need to get used to thinking of data as if it were an index.

Te main challenge when designing and building the data layer of a scalable web application is identifying `access patterns` and `modeling your data based on these access patterns`.

优化数据模型通常会降低灵活性，增加灵活性通常会降低性能和伸缩性。

RDBMS的设计结果 you would usually end up with a normalized and ﬂexible `database schema` that could be used to answer almost any type of question using SQL queries.

Your schema（数据库schema） would be designed mainly based on the data itself, not queries or use cases. 有时为了业务查询调整shcema设计，比如为减少SQL执行次数，将需要同时查询但并不强相关的信息放在一起，这跟下面的NoSQL的做法有点类似

NoSQL data stores trade `data model ﬂexibility` (and ability to perform joins) for `scalability`。Designing a NoSQL data model is much more about tradeoffs and data layout optimization than it is about normalization.

而设计NoSQL的data model时相反，需要先考虑the queries and access patterns

将大部分数据组合到一个entity，通过一次查询即可获得所有需要的数据，不需要join、跨服务器查询或使用多个索引。

`data denormalization` and `modeling with queries`
- benefits
    - 即使是大数据集合下，性能和效率都很好
    - 数据一般是单一索引，降低磁盘操作，减少IO压力
- drawbacks
    - 数据冗余
    - 更新数据变得困难

NoSQL按支持的`data model`分类
- Key-value data stores
    - Redis, Memcached, Dynamo, Riak
- Wide columnar data stores
    - BigTable, Cassandra, HBase
- Document-oriented data stores
    - MongoDB, CouchDB, CouchBase

Many NoSQL data modeling techniques can be boiled down to building `compound indexes` so that data can be located effciently.

data store中使用索引很难满足所有case，此时可用专用的搜索引擎

#### Search Engines
让用户执行大范围的查询（大数据量）要么需要为特定场景构建大量专用索引，或者使用专用搜索引擎。

Te core concept behind `full text search` and `modern search engines` is an `inverted index`.

搜索引擎中，or的代价相对叫高

- Amazon CloudSearch
- Azure Search
- Elastic Search
- Solr
- Sphinx

### Chapter 9 - Other Dimensions of Scalability
For your applications to be truly scalable, you need to be able to scale the size of your teams, the number of servers you support, and your own personal productivity, minimizing the costs (time and money) at the same time.

#### Scaling Productivity through Automation
- Testing
    - 单测、回归、集成测试。Jmeter，Selenium
- Build and Deployment
    - automate the entire build, test, and deployment process by adopting
        - continuous integration: 自动打包构建和自动化集成测试
        - continuous delivery: 自动编译、组装、部署到一个类生产环境
        - continuous deployment: 自动测试、构建、部署并推送到生产环境
    - 持续部署工具：Jenkins、Atlassian Bamboo
    - 还要考虑管理服务器配置（manage confguration of your servers）：Chef，Puppet
        - Te goal is to store server confguration in the source control system to be able to re-create servers at any point in time and track changes.
    - How do you make sure that things don’t break if every commit goes straight to production?
        - 单测 85%以上覆盖
        - Create end-to-end test cases for all critical paths like sign up
        - Use feature toggles to enable and disable selected features instantly.
        - Use A/B tests and feature toggles to test new features on a small subset of users.
        - Use a wide range of monitoring tools...configure alerts on critical metrics.
- Monitoring and Alerting
    - 降低mean time to recovery (MTTR)，提高可用性
    - MTTR = Time to discover + Time to respond + Time to investigate + Time to fix
    - To get the most out of your monitoring confguration, you should collect four diﬀerent types of metrics
        - Operating system metrics
        - Generic server metrics：QPS。。。JVM, TOMCAT
        - Application metrics：外部调用。。
        - Business metrics：资金、账号、购物车等
    - 常用方案：每台服务器安装监控代理，数据发送到中央服务器
        - Datadog、StackDriver、New Relic、Server Density
    - 还有外部方案：external service level agreement (SLA) monitoring service. 从外部（各地域）模拟客户连接，探测各类问题
        - Pingdom, Moniris, Keynote
- Log Aggregation
    - 小规模一般到各个机器grep查看，但一旦机器数量太大时会用到
    - 将日志直接记录到数据库，一般不推荐
    - 仍写到本地，然后传到中央日志服务（每台服务器安装一个日志转发代理）
    - Fluentd
    - 日志聚合索引、日志搜索：Splunk、Loggy、LogStash（开源）

想实现可伸缩性，测试和部署必须实现自动化

Setting up a continuous deployment pipeline is challenging because it requires skills from both ends of DevOps. You need to have `Dev’s knowledge` of the code and testing tools and `Ops’ expertise` in setting up servers and deploying software and managing confgurations.

#### Scaling Yourself
1. Overtime（加班） Is Not a Way to Scale

not to fall into a blind race, as working can easily become a thoughtless compulsion.

`As you work longer hours for extended periods of time, your mental capacity decreases; your creativity drops; and your attention span, field of vision, and ability to make decisions all degrade. In addition, you are likely going to become more cynical, angry, or irritable. You will resent people who work less than you do; you will feel helpless or depressed in the face of an evergrowing pile of work. You may even begin to hate what you used to love doing or feel anxious, with the only way to repress this anxiety being to work even harder.` All of these are symptoms of `burnout`.

2. Managing Yourself
A good way to look at the problem of maximizing your own productivity is `to look at your workload as if you were managing a project` and all of your potential tasks were parts of this project. When managing a project, you have three “levers” allowing you to balance the project: `scope`, `cost`, and `time`.

Anytime you increase or decrease the scope, cost, or deadline, the remaining two variables need to be adjusted to reach a balance. 三者呈现一个相互影响的三角

The first thing that you need to do is to accept the fact that `managing a project is about making tradeoﬀs`.

- Inﬂuencing the Scope
    - learning how to prioritize tasks based on their cost and value is the most important skill in managing scope.
    - This inability to evaluate the true value of features is what leads most companies to develop things that nobody needs.
    - Although `the 80/20 rule` is a simplifcation, by realizing it, you can reduce the time spent on gold plating and make sure that you stop working on the task as soon as it is “complete enough” rather than trying to reach the 100 percent, regardless of the cost.
    - 二八法则
        - 和利益相关者一起讨论，将新特性的范围缩小至80%，延迟最困难部分的交付时间
        - 保持功能最小化和简单化
        - 只实现绝对必要的代码，不要添加哪些“有也不错”的参数、类和方法，这些都需要测试、文档、理解、管理等，少即是多
        - 单测覆盖85～90即可
        - 文档，关注信息和高层试图，不必为所有方面添加文档
        - 不出故障不要修改代码，可在修改代码时顺便重构
        - 区分“我必须要做的“和“我想要做的”
        - 不到万不得已不要去做伸缩或者优化，可以规划，但只到必要时在添加
    - 我们希望UI漂亮、后端是优化的、数据一致、代码干净、但除非你有无穷尽的时间，否则就要做tradeoff
- Inﬂuencing the Cost
    - 任务委派给团队内其他人或第三方
    - 如果你是完成任务的唯一人选，则会出现单点瓶颈，让多个人都能处理该任务
    - 同一任务，多人参与，获得突破和创新的概率更大
    - 一些实践方法：分析知识和责任
        - 结对编程：不一定总是这样，每周一次
        - 临时讨论会（Ad hoc design sessions）
        - 持续code review
    - 使用三方产品
- Inﬂuencing the Schedule
    - `Rather than passively listening for commands`, you should `actively provide feedback` to your business leaders, letting them know which features are cheap and quick to build and which ones are expensive or risky.

#### Scaling Agile Teams
增加人手
- 人少，几乎可立即知道发生了什么，人一多沟通路径会迅速增加，不可能让每个人及时了解最新的状况
- 解决的常见方法是拆分为小团队，每个小团队专注不同领域，但这样不可避免的会出现踢皮球、政治斗争、互相指责和推卸责任等现象
- 这种工作效率低下的情况是因为团队是根据工作职责划分的，而不是基于产品开发，后果是产品被分为一段一段的，每个团队只关注自己负责的那一块，而不会考虑整体的产品目标。另一种方法是**创建跨职能团队**，该团队按产品和服务组建，这种团队更适合创业公司

Procedures and Innovation
- Another important part of scaling your engineering department is to get the right balance among `procedures`, `standards`, and `autonomy of your teams`(自主性)。但标准和流程同时也牺牲了团队的自主性、弹性和创新的精神

Culture of Alignment 结盟文化
- Te last, but not least, important facet of scaling technology organizations is to align your teams on `common goals` and `build a good engineering culture`.

`Remain pragmatic and never stop learning`. Building software, and especially scalable software, is a game of tradeoﬀs, and there is never a single right way to do things.

`For people to be productive, healthy, and happy, you need to create an environment where everyone can feel safe and accepted, and where people get support from their peers.` The good news is that it is in everyone’s capacity to ignite and foster a good engineering culture. You do not have to be a CEO to do this.

