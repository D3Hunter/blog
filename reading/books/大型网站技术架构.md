## 大型网站技术架构：核心原理与案例分析 李智慧
作者特别喜欢用“架构”，“分布式”，有些概念都混淆了，前半部分还行

大型网站相比传统软件的差异
- 高并发+大流量
- 高可用
- 海量数据
- 用户分布广泛，网络情况复杂
- 安全环境恶劣
- 需求快速变更，发布频繁
- 渐进式发展

### Chapter 1 - 大型网站架构演化
- monolithics
- 组件分离
- 缓存
    - 二八原则：80%的业务集中在20%的数据上
    - 本地缓存、分布式缓存
- 横向增加服务器、纵向提升单个服务器配置
- 数据库读写分离
- 使用反向代理和CDN加速网站响应
    - 都是通过缓存（反向代理处理静态页面？）
    - CDN：从最近的网络提供商的机房获取数据
- 使用分布式文件系统和分布式数据库系统
    - 单表数据量非常庞大时才会考虑分布式数据库，否则更常见的是业务分库，不同业务的数据放在不同数据库中。分库分表
- 使用NoSQL和搜索引擎
    - 网络越来越复杂，对数据存储和检索的需求越来越复杂
- 业务拆分
    - 使用分而治之的方法将网站业务分为不同的产品线，各产品通过消息进行通信（如消息队列，超链接等）
- 分布式部署
    - 将应用中都需要执行的相同的业务操作，如用户管理、商品管理等，提取出来独立部署

架构演变到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站的业务问题都可通过组合或改进现有技术架构来解决

小型网站最需要做的是为用户提供更好的服务来创造价值，得到用户认可，活下去，野蛮生长

LAMP便宜又简单，对付一个中小型网站足够了

大型网站架构技术的核心价值是随网站所需灵活应对。驱动其发展的主要力量是网站的业务发展

大型网站设计误区
- 一味追随大公司的解决方案：借鉴而不盲目
- 为了技术而技术：不能脱离实际业务
- 企图用技术解决所有问题：有时需要调整的是业务架构，而非技术架构
    - 技术是用来解决业务问题的，而业务的问题也可以通过业务的手段来解决

### Chapter 2 - 大型网站架构模式
模式：每一个模式描述了一个在我们周围不断重复发生的问题及该问题解决方案的核心，这样就能复用改方案而不用重复工作

问题和场景的可重复性，带来解决方案的可重复性

- 分层
    - 逻辑上的划分
    - 便于分工开发和维护
    - 需要合理规划层次边界和接口
    - 大的分层结构可继续细分，如服务层可分为数据接口层（适配输入输出）和逻辑处理层
    - 分层对网站支持高并发和向分布式方向发展至关重要
- 分割
    - 如果说分层是将软件横向切分，分割则是纵向切分
- 分布式
    - 提高可处理的并发数和数据量
    - 模块间需要走网络通信，有性能损耗
    - 更多的服务器，带来更多的机器宕机，影响可用性
    - 数据一致性、分布式事务
    - 模块间依赖复杂度上升，增加开发维护成本
    - 量力而行，不能为了分布式而分布式
    - 常见方案
        - 分布式应用和服务
        - 分布式静态资源：动静分离
        - 分布式数据和存储
        - 分布式计算
        - 分布式配置，服务器配置实时更新
        - 分布式锁，实现并发和协同
        - 分布式文件系统，云存储等
- 集群
    - 多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务
- 缓存
    - 缓存就是将数据放在里计算最近的位置以加快处理速度
    - 具体方式
        - CDN
        - 反向代理：缓存网站静态资源，无需通过应用服务器
        - 本地缓存
        - 分布式缓存
    - 两个前提
        - 缓存的数据会被频繁访问
        - 缓存的数据需要在某时间段有效，太快失效就失去缓存的价值
- 异步
    - 多线程共享内存队列，前读后写
    - 生产者消费者模式
    - 特性
        - 提高系统可用性
        - 加快网站响应速度
        - 消除并发访问高峰：漏桶方法
    - 可能对用户体验和业务流程造成影响，需要网站产品设计的支持
- 冗余
    - 服务器冗余运行、数据冗余备份
    - 多台服务器（相同服务）构成集群，通过冗余实现高可用
    - 数据库定期备份（冷备份），还需要数据库的主从分离，实时同步，实现热备份
    - 抵御地震、海啸等不可抗力，对整个数据中心进行备份，全球范围内部署灾备数据中心
- 自动化
    - 发布运维的自动化
    - 发布自动化
    - 代码管理自动化，版本控制，分支创建合并
    - 自动化测试、安全检测、部署
    - 自动化监控、报警、失效转移（将故障服务器移除集群）、失效恢复
    - 自动化服务降级（遇到访问高峰，通过拒绝部分请求或关闭不重要的服务等方式，保证网站整体安全可用）
    - 自动扩容（自动化资源分配）
- 安全
    - 密码+手机校验码进行身份认证
    - 网络通信、数据加密
    - 使用验证码，避免机器人程序攻击，Dos
    - 处理常见网站攻击方式：XSS、SQL注入等
    - 过滤垃圾、敏感信息
    - 对交易转账等重要操作进行风险控制

分层和分割，可以看成`模块化`的两种形式，这样同样便于后续的分布式部署

Hadoop和MapReduce分布式计算框架特点是移动计算而非移动数据，将计算分发到数据所在位置以加速

系统架构的分层划分
- API
    - 客户端和三方应用通过API接入
- 平台服务、应用服务
- 基础服务
    - 数据库、缓存、存储、搜索，及其他基础技术服务

单机部署模式：使用多个端口部署相同服务；单机虚拟化后，每台虚拟机单独部署

### Chapter 3 - 大型网站核心架构要素
除了满足基本功能需求，架构还需要关注性能、可用性、伸缩性、扩展性、安全性

clock time去掉故障时间，就是网站的总可用时间，除以clock time可以得到网站的可用性指标，比如4个9: 99.99%

网站高可用的主要手段时冗余，通过服务集群，一台服务器宕机，只需将服务转移到其他服务器上，前提时会话信息需要存储在其他地方，保证可转移恢复。还需要通过开发过程中的质量保证，通过预发布验证、自动化测试和发布、灰度发布，减少将故障引入线上

衡量高可用：假设一台或多台服务器宕机，以及各种不可预期的问题时，系统整体仍然可用

衡量伸缩性：
- 是否可用多台服务器构建集群
- 是否容易向集群中添加／删除服务器
- 添加／删除服务器能否保证无差别服务
- 集群可容纳的服务器是否有限制

对于缓存服务器集群，添加服务器可能导致缓存路由失效

关系型数据库虽然支持数据复制，主从热备等机制，但难以做到大规模集群的可伸缩性，因此数据库集群的伸缩方案需要在数据库外完成，如路由分区等

网站可扩展性架构的主要手段是事件驱动和分布式服务
- 事件驱动通常通过消息队列实现，分离生产者和消费者，后续可透明新增生产者或消费者
- 分布式服务（部署？）将业务与可复用服务（中台／平台）分离，新产品可复用中台实现自身业务逻辑，中台可通过多版本服务实现透明升级

大型网站为保持市场地位，建设生态，吸引三方开发者，主要通过网站提供的各种接口

### Chapter 4 - 瞬时响应，网站的高性能架构
网站性能是客观的指标，可通过响应时间、吞吐量等指标体现，同时也是主观的感受（用户），从用户和工程师的角度是不同的

响应时间、吞吐、并发、性能计数器（load、thread count、cpu、disk、network）

Latency + Processing Time = Response Time

优化手段，参考【大型网站架构演化】部分

网站系统用户数 >> 网站在线用户数 >> 网站并发用户数

产品设计初期，需要规划不同发展阶段的网站系统用户数，基于此推算在线和并发用户数

压力测试：评估可能导致系统崩溃的最大访问负载压力

使用浏览器缓存策略的网站在更新静态资源时，最好批量逐步更新，避免大量客户浏览器缓存失效，造成服务器压力骤增

静态资源使用独立域名，避免发送大量cookie

- `缓存热备份`，提高缓存可用性，当缓存服务器宕机时切换到热备份服务器上。
- `缓存预热`
- 缓存穿透：缓存中未保存某不存在的数据，直连数据库。可将“不存在”这种情况也缓存起来

分布式缓存：
- 各节点同步更新
- 各节点互不通信: 缓存与应用分离部署，通过一致性hash等算法路由cache访问
- hybrid

缓存集群内部互不通信可以做到无限制的线性伸缩

#### 应用服务器优化
- 缓存
- 异步
- 集群
- 代码层

代码层优化
需要使用profiler/distributed profiler定位出瓶颈点，CPU／磁盘／网络，分布式的还要考虑各个节点情况
- 多线程
- 资源复用：创建开销大的对象（db/remote connection，thread，complex object）
    - singleton／object pool
- 数据结构
- 算法
- 利用业务逻辑
- JVM参数（GC）：限java应用，可能需要配合代码层

启动线程数估算
- 启动线程数 = (任务执行时间 ／ (任务执行时间 - IO时间)) * 核数
- 启动线程数 = (1 ／ (任务执行时间 - IO时间)) * 核数

解决线程安全问题
- 使用无状态对象
- 使用本地变量／TLS
- lock

#### 存储性能优化
RAID HDFS

### Chapter 5 - 网站的高可用架构
网站不可用也被称为网站故障，业界通常用多少个9来衡量网站可用性
- 99% 基本可用，网站年度不可用时间 < 88小时
- 99.9% 较高可用，网站年度不可用时间 < 9小时
- 99.99% 具自动恢复能力的高可用，网站年度不可用时间 < 53分钟
- 99.999% 极高可用，网站年度不可用时间 < 5分钟

可用性指标指网站或产品的整体考核指标，具体到某个工程师，更多的是使用故障分。故障分指对网站故障进行分类加权计算故障责任的方法，计算公式
- 故障分 = 故障时间（分钟） * 故障权重

网站可用性跟技术、运营和相关各方绩效考核息息相关，因此在架构设计和评审会议上，关于可用性的讨论和争执总是最耗时费精力的。

通常企业级应用系统为提高可用性，会采购较昂贵的软硬件设备（IOE），IBM小机、Oracle数据库、EMC存储。互联网常采用PC级服务器

实现高可用的主要手段是数据和服务的冗余备份和失效转移。

服务层是在应用层内实现负载均衡，通过服务注册中心(zookeper?)记录可用服务器列表

集群下的session管理
- session复制：小规模集群时还可以，大规模时会占用大量服务器和网络资源，以及session占用过多内存
- session绑定：一致性hash、session绑定，不满足高可用需求
- cookie记录session：大小限制，影响网站性能（每次都需要传输）。用户可能关闭cookie
    - 简单易用，支持服务器线性伸缩，大部分网站记录的session信息较小，一般网站会使用该方式
- session服务器
    - 拆分为无状态的应用服务器，和有状态的session服务器
    - 如使用分布式缓存、数据来实现

高可用的服务
- 分级管理
    - 核心非核心应用
    - 部署隔离，避免连锁反应
- 超时设置
    - 请求超时后，切换到其他服务器
- 异步调用
- 服务降级
    - 拒绝服务：如随机拒绝
    - 关闭服务：关闭非核心或不重要的服务
- 幂等设计
    - 服务重复调用不可避免，就算服务层成功，应用层因收不到回复也会认为失败
    - 一些服务天生幂等，如设置性别
    - 涉及转账交易等，则需要交易编号等信息进行校验

高可用的数据
- 主要手段为数据备份和失效转移机制
- 缓存服务的高可用，两种观点
    - 需要高可用
    - 利用其他手段解决，而不是提高缓存服务本身的高可用：扩大缓存服务集群，整个网站共享该集群等
- CAP
    - 为了保证数据的高可用，网站通常会牺牲数据一致性
    - CAP原理认为，一个提供数据服务的存储系统无法同时满足
        - 数据一致性（consistency）
            - 数据强一致
            - 数据用户一致：一般是这种
            - 数据最终一致
        - 数据可用性（availibility）
        - 分区耐受性（partition tolerence）：系统可跨网络分区线性伸缩
    - 12年淘宝双11，由于较弱的数据一致性导致部分商品超卖
- 数据备份
    - 冷备份
    - 热备份：异步、同步
- 失效转移
    - 失效确认：心跳，应用程序访问失败报告
    - 访问转移
    - 数据恢复：避免再有宕机，访问无法转移，导致数据永久丢失

高可用网站的软件质量保证
- 网站发布，大型网站发布频繁
- 自动化测试
    - selenium
- 预发布验证：测试环境的数据库、缓存、三方服务等跟线上不同，有时测试环境没问题，生产有问题
    - 跟生产环境的唯一区别就是没配置在负载均衡服务器中，外部无法访问
    - 预发环境连接是生产库，测试时需要谨慎，避免测试的数据改动被用户看到，导致不可预知的结果
        - 如更改了某商品价格，导致大量成交，造成损失
    - 快速失败，遇到问题／异常立即失败，避免执行错误的操作
- 代码控制：主干发布／分支开发，分支发布／主干开发。。
- 自动化发布：人的干预越少，自动化程度越高，引入故障的可能性就越小
- 灰度发布：发布成功后仍有可能发现新的问题，此时需要做发布回滚
    - 可分批次／分区域发布，每批次发布后需验证结果再继续
    - 也用于测试新版本，AB测试

网站运行监控：“不允许没有监控的系统上线”
- 监控数据采集
    - 用户行为日志收集
        - 服务端日志收集
        - 客户端日志收集
    - 服务器性能监控
    - 运行数据报告
        - 缓存命中率、每分钟邮件数目、待处理任务数等等
- 监控管理
    - 系统报警
    - 失效转移
    - 自动优雅降级

对公司而言，可用性关系网站的生死，对个人而言则是绩效升迁。工程师对架构做优化，代码重构，对性能、扩展性、伸缩性做了很多改善，但别人未必能直观的感受到，也许你的leader都不知道你做的事情的意义何在。但如果你负责的产品除了故障，CEO都会知道你的名字。事物总是先求生存，后求发展，保证网站可用，任重道远。

### Chapter 6 - 网站的伸缩性架构
网站的伸缩性：不需要更改网站的软硬件设置，仅通过改变部署的服务器数量就可以扩大或缩小网站的服务处理能力

伸缩设计
- 根据功能进行物理分离实现伸缩？
    - 纵向分层
    - 横向业务分割
- 单一功能通过集群实现伸缩？

1. 应用服务器集群的伸缩设计
负载均衡
- HTTP重定向：简单，性能较差，很少用到
- DNS域名解析：DNS为多层解析且缓存，失效服务器下限较慢
- 反向代理：应用层负载均衡
- IP负载均衡：网络层更改请求目标地址
- 数据链路层负载均衡（直接路由方式，DR）：更改目标mac。三角传输模式
    - 目前大型网站最广泛使用的，linux下可使用LVS（Linux virtual server）

负载均衡算法（路由算法）
- 轮询 RR
- 加权轮询 WRR，比如不同服务器硬件有差异的情况
- 随机
- 最少连接
- 原地址hash：实现会话黏滞

2. 缓存服务器的伸缩设计
加速数据读取，减轻存储服务器压力

不同服务器缓存的数据不同，因此不能直接访问集群内任意一台服务器，必须找到包含有该数据的服务器在访问。必须让新上线的缓存服务器对整个分布式缓存集群影响最小，这是缓存服务器的伸缩设计的重要目标

对KEY做hash，计算需要到哪台服务器读写数据

Memcached分布式缓存集群的伸缩性挑战：扩容后如何保证缓存命中率（2的幂次方扩容能保证50%，但资源浪费较大）
- 访问量较小时扩容，逐步预热，减少影响
- 一致性hash算法
    - 一个问题是一致性hash仅分摊了部分节点的压力，其他节点压力仍在：增加一层，将物理服务器虚拟为一组虚拟服务器，先在hash环上找到虚拟服务器，再找到物理服务器，虚拟服务器数量太多影响性能，太少会导致负载不均衡，经验值是1:150

3. 存储服务器的伸缩设计
对数据的持久性和可用性提出了更高要求

关系型数据库的伸缩设计
- RDBMS一般都有数据复制功能，可使用该特性实现简单伸缩，主从读写分离
- 业务分割，数据分库，无法跨库join
- 一些表即便在分库和主从分离后仍然太大，需要进行分片，相关产品有阿里的Cobar
    - cobar本身的伸缩可使用应用服务器伸缩的方法
    - 数据库的伸缩，要保证负载均衡，需要做数据迁移，将原集群的数据迁移到新实例。Cobar使用MySQL的数据同步功能，以schema为单位
    - cobar无法跨库join和事务处理
- 分布式数据库

NoSQL数据库的伸缩设计（书里提到的NoSQL一般不指redis等一般用作缓存的内存数据库）。

高手定律：这个世界只有遇不到的问题，没有解决不了的问题，高手之所以成为高手，是因为他们遇到了常人很难遇到的问题，并解决了，如百度有很多搜索高手，淘宝很多海量数据高手，QQ有很多高并发业务高手。。。

没有救世主定律：很多问题只是看起来一样，具体问题需具体对待，没有银弹（救世主），遇到问题急忙招个“高手”，期望其轻松搞定，往往只留下失望和抱怨。

### Chapter 7 - 网站的可扩展性架构
网站可扩展性架构（这里是架构层面的，代码层面、模块内部的还有区别）的核心思想是模块化，降低模块间耦合性，提高模块复用性。模块内部通过消息传递或依赖调用方式聚合。

1. 分布式消息队列
模块间不存在直接调用，新增或修改模块对其他模块影响很小
- 事件驱动：生产者消费者。消息的异步处理。消息暂存在消息队列，限流，减轻后端压力
- 分布式消息队列
    - 相关产品较多，除实现基本功能外，他们在性能、可用、伸缩、数据一致性和可管理性上做了很多
    - 也可以使用MySQL等数据库来实现消息队列

服务接口的版本管理

4. 可扩展的数据结构
RDBMS的设计范式（字段、类型等）带来的问题是僵硬的数据结构难以面对需求变更带来的挑战。有些系统会预先设计冗余字段，但这是一种糟糕的数据库设计

NoSQL的columnFamily设计

5. 利用开放平台构建网站生态圈

### Chapter 8 - 网站的安全架构
1. 网络攻防
- XSS：一种`code injection`攻击
    - 消毒：数据处理转义
    - HttpOnly
- SQL注入
    - 数据预处理
    - PreparedStatement
- CSRF
    - 识别请求者身份：表单Token，验证码，Referer Check
- SESSION劫持
- ERROR CODE 错误回显／HTML注释，报漏内部信息。跳转到专门的页面／发布前代码扫描过滤
- 文件上传：上传攻击性的脚本会可执行文件
    - 设置白名单、限制文件类型、更改文件名、使用专门的存储空间
- 路径遍历：攻击者利用请求中的相对路径，遍历系统未开发的目录和文件
    - 静态资源分离，其他资源不使用静态URL，动态参数不含路径信息
- 使用WEB应用防火墙(`web application firewall (WAF)`)产品：开源的如ModSecurity
- 网站安全漏洞扫描

2. 信息加密和密钥安全管理
- hash function：不可逆，MD5、SHA
- 对称加密
- 非对称加密

实际信息安全传输场景，常用非对称加密传输密钥，使用对称加密加密信息

代码中或配置中明文存储密钥（或线上线下两套密钥，本质上差别不大，存在安全风险。

密钥管理
- 使用专门的密钥及算法服务器，提供加解密服务
- 算法在应用本地，密钥在独立服务器，存储时切片存放在多个存储介质中

3. 信息过滤和反垃圾
- 文本匹配：过滤敏感词（Trie树，同一层内hash存储）
    - 有时某些信息为绕过敏感词会添加干扰，需要先做降噪处理
- 分类算法：贝叶斯、TAN、ARCS
- 黑名单：
    - hash，如果黑名单很大，如10亿条（1G），如果单个hash为8B，加上一半的冗余，则需要16GB的空间
    - 唯一查找，可通过其他搜索方法，B+树
    - 对精确度要求不高可使用布隆过滤器

4. 电子商务风险控制
- 账户风险：黑客盗用、恶意注册
- 买家风险：恶意下单、拒收、低价恶意抢购、欺诈退款
- 卖家风险：货不对板、虚假发货、炒作信用、违禁品、侵权商品
- 交易风险：信用卡盗刷、支付欺诈、洗钱套现

风控
- 规则引擎
    - 简单，规则增多时相互冲突、难以维护。规则越多性能越差
- 统计模型

### Chapter 9 10 11 12 13
GeoDNS: 将域名解析到离用户最近的服务器

如果master数据库宕机，立即切换到slave服务器，同时关闭数据写服务，即禁止编辑。Wikipedia通过约束业务获得更大的技术方案选择余地，很多时候业务后退一小步，技术就可以前进一大步。

#### 秒杀系统：瞬时的上百／千倍的并发
- 对现有业务造成冲击
- 高并发性的数据库、应用负载
- 突发的网络、服务器带宽

部署策略
- 秒杀系统独立部署，甚至使用独立域名，与现有系统隔离
- 秒杀商品页面静态化
- 租借秒杀活动网络带宽
- 动态生成随机下单界面URL

需面对的其他问题
1. 如何控制秒杀商品页面购买按钮的点亮：可用每次刷新都变更的js脚本控制
2. 如何只允许第一个提交的订单被发送到订单子系统：全局计数器，前面介绍的提高性能的架构设计等

典型故障案例分析：在高并发和海量数据的情况下，很多一般情况下不是问题的问题都会涌现出来。

下面的问题大部分是开发／发布流程导致的：开发测试自动化、codereview要加强，不能让未review、未严格测试的代码上线
1. 写日志引发故障：日志级别，日志文件rolling
2. 高并发访问数据库引发的故障：首页是动态的，导致高频访问数据库。可缓存，或改为静态页面
3. 高并发下锁引起的故障：某个RPC操作也加了锁，使用锁需谨慎；代码写的不好，需要review
4. 缓存故障，缺乏经验的工程师删除了缓存集群。这种是线上变更规则问题，为什么让新手在缺乏结对的情况下直接操作线上缓存集群
5. 应用启动不同步引起的故障：backend-server未启动完成时，frontend-server就开始接受请求了。这个需要从发布流程、系统的完整性校验（系统ready了再提供服务）上来解决
6. 大文件读写独占磁盘：不同大小的文件分离存储、限制文件大小等
7. 滥用生产环境：线上操作要有规范，避免测试等操作
8. 不规范的流程，关键代码被注释后被提交，加强代码开发流程了codereview
9. 不好的编程习惯：代码编程规范、codereview

null判断属于data normalizetion的问题，如果是在系统内，需要在数据入口保证，而不是每个点都检查null

