javaagent
    javaAgent是从JDK1.5引入
    由底层叫instrument的JVMTIAgent实现（Linux下对应的动态库是libinstrument.so
    因为javaagent功能就是它来实现的，另外instrument agent还有个别名叫JPLISAgent
        (Java Programming Language Instrumentation Services Agent)
    调试用到的JVMTIAgent：-agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:6134

    javaagent需要在META-INF/MAINIFEST.MF添加Premain-Class
    -javaagent参数需要放到main所在类前面，否则不会执行
    javaagent在instrument收到VMInit后开始执行，即运行在live phase
        如果instrument为attach方式，也是live phase

class必须放到对应包名的目录下才能由java找到

jar tvf xxx.jar

JNI使java代码调用或被本地代码（用C/c++等写的直接在硬件上跑的代码）调用的框架

The JDK, the JVM and other JDK tools find classes by searching the Java platform (bootstrap)
    classes, any extension classes, and the class path, in that order.
    但是使用的是委托模型

How the Java Launcher Finds Classes
    Bootstrap classes(Bootstrap class loader) - Classes that comprise the Java platform,
        including the classes in rt.jar and several other important jar files.
    Extension classes(Extensions class loader) - Classes that use the Java Extension mechanism.
        These are bundled as .jar files located in the extensions directory.
    User classes(System class loader/App class loader) - Classes defined by developers and third
        parties that do not take advantage of the extension mechanism. You identify the location
        of these classes using the  -classpath option on the command line (the preferred method)
        or by using the CLASSPATH environment variable. (See Setting the Classpath for Windows or
        Unix.)

除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。

Bootstrap Class path and system class path
-Dname=value会将其放到System.properity中

Q:
    StartAgent

Instrumentation
    addTransformer
    redefineClasses

eclipse
    Window -> Preferences -> General -> Workspace Encoding
ZKM(Zelix KlassMaster): java obfuscator
Project Object Model, or POM

IntelliJ导入maven工程需要单独导入modules，即需要两步

mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
    You executed the Maven goal archetype:generate
    a plugin is a collection of goals with a general common purpose
    package. Rather than a goal, this is a phase. A phase is a step in the build lifecycle, which is an ordered sequence of phases.

Agent start-up
    OnLoad phase calls OnLoad
        Agent_OnLoad,Agent_OnUnload
    Live phase calls OnAttach

bytecode instrumentation (BCI ASM)
    仅仅在 AdviceAdaptor 的 methodExit 添加代码还不够，因为 RuntimeException 并不会显示抛出
        因此需要添加方法整体的 try-catch，并在在 visitMaxs 添加 methodExit 处理
    MethodNode的accept会复现一遍该node
    为类添加getter，如果field为父类的private会报错，需要调整其access

Java agents
    premain
    通过Instrumentation object能做的操作：
    rewrite methods
    reload new class without restarting JVM
    使用ASM：bytecode->DOM-like structure->modify->save to be bytecode
    更靠后的节点，受限于JVM
    获取GC信息需要辅助agent
Native agents
    GC, locking, code manipulation, synchronization, thread management, compilation debugging，etc.
    Issues related to: Complex,Portability,Stability
    不受full gc暂停限制，可继续发送数据
    dynatrace使用该方法
        Full Insight of all Classes
        More detailed information
        Additional information
            a crash caused by an Out-of-Memory Error情况下继续运行
        Less impact on JVM
            java agent会占用更多heap
        Performance
            一些数据的获取需要Java to Native的过程
        Not attached to JVM
            full gc的暂停
JAVA_TOOL_OPTIONS可用来传递agent参数
ClassFileLoadHook
Instrumentation
    Static Instrumentation，另外的文件夹
    Load-Time Instrumentation，javaagent
    Dynamic Instrumentation，RetransformClasses->ClassFileLoadHook
The JVM TI interface pointer is called the environment pointer. An environment pointer is a pointer to an environment and has the type jvmtiEnv*. An environment has information about its JVM TI connection. The first value in the environment is a pointer to the function table. The function table is an array of pointers to JVM TI functions. Every function pointer is at a predefined offset inside the array.
JVM TI functions always return an error code via the jvmtiError function return value
References passed to JVM TI functions can be either global or local, but they must be strong references.
All references returned by JVM TI functions are local references--these local references are created during the JVM TI call. Local references are a resource that must be managed
A thread is ensured the ability to create sixteen local references without the need for any explicit management.（PushLocalFrame and PopLocalFrame.）
"Required Functionality" means it is available for use and no capabilities must be added to use it. "Optional Functionality" means the agent must possess the capability before it can be used.
another environment possesses capabilities that can only be possessed by one environment, or the current phase is live, and certain capabilities can only be added during the OnLoad phase.

java <class-name>中class-name格式为点分或/分，不包含最后的.class

Get Phase列出了各个phase能够使用的函数列表


JVM heap的MAX大小是不可动态改变的

gdb直接运行JVM会出现SIGSGEV，这是由于java代码中的NullPointerException,可参考下面的bug链接

All libraries loaded into java are assumed to be MT-safe (Multi-thread safe)

VMSTART中调用JNI的FindClass崩溃问题，参考JDK-8078653,VMStart阶段调用没问题

GetSystemProperty/ies只能在Onload和live phase阶段用
Exception/Catch只能在live用

每个线程都有一个jni环境

The test with an incorrect classpath crashes because the agent VMStart callback is trying to load an agent class that is not on the classpath.
It is the responsibility of the agent to be careful in the callbacks especially in the VMStart event when the VM has not finished the initialization yet.

ClassSignature中generic signature似乎包括所有显示标明继承的类，实现的接口
    而type signature则没有

IterateOverReachableObjects，遍历所有对象，不会改变object状态，可能会导致java程序暂停
FollowReferences获得object关系树


jobject NewGlobalRef(JNIEnv *env, jobject obj);

Creates a new global reference to the object referred to by the obj argument. The obj argument may be a global or local reference. Global references must be explicitly disposed of by calling DeleteGlobalRef().


怎么拦截main函数的执行
    main所在class是在执行完main后才发送的ClassLoad事件
    main所在的线程是什么，threadinfo中name为main
    main是在VMInit后执行的（可以在这里处理Class）

JNI：
    static函数第二个参数为jclass，成员函数为jobj
    java部分，函数标为native
    函数命名规则，Java_<full_class_name>_<method>
    javah可以为用JNI的class生产header
    NewStringUTF创建字符串
    创建java中的对象，需要FindClass然后再创建，数组创建如下：
        NewObjectArray，SetObjectArrayElement

heap遍历reference需要先添加tag，否则无法获取谁是谁
jvmtiHeapReferenceCallback
    如果referrer object是一个runtime class，那么其referrer_class_tag为java.lang.Class的tag
    上面的规则类似回调也适用
    如果某个object的field为null这时不会生成reference

sun/launcher/LauncherHelper的啊哦哦Class会指向main所在class

java_crw_demo  class reader writer

jstack可以看各个线程当前的stack-trace
javap -l可以显示debug符号表，查看是否有变量表，但没变量表也能调试

References
http://blog.takipi.com/double-agent-java-vs-native-agents/
http://apmblog.dynatrace.com/2014/01/15/pros-and-cons-of-using-java-vs-native-agent-for-application-performance-management/
http://jonbell.net/2015/10/new-blog-series-java-bytecode-and-jvmti-examples/
https://bugs.openjdk.java.net/browse/JDK-8136586
http://www.students.ic.unicamp.br/~jugic/PUB/jdk1.5.0/demo/jvmti/
http://jonbell.net/2015/10/new-blog-series-java-bytecode-and-jvmti-examples/
https://bugs.openjdk.java.net/browse/JDK-8078653

sudo ln -sf /home/ubuntu/programs/jdk1.8.0_74/bin/java   /usr/bin/java
sudo ln -sf /home/ubuntu/programs/jdk1.8.0_74/bin/javac  /usr/bin/javac


JAXB
    通过xml标记直接得到某个xml结构的bean
    com.blueocn.tps.dm.util.jobs.Jobs有时间研究下，这太方便了

Quartz调度库
    Scheduler - the main API for interacting with the scheduler.
    Job - an interface to be implemented by components that you wish to have executed by the scheduler.
    JobDetail - used to define instances of Jobs.
    Trigger - a component that defines the schedule upon which a given Job will be executed.
    JobBuilder - used to define/build JobDetail instances, which define instances of Jobs.
    TriggerBuilder - used to define/build Trigger instances.

    org.quartz.jobStore.useProperties默认使用Serialize对象，这时设置用户属性对象必须是
        serialize的对象

Lombok字节码自动插入，设置getter/setter/constructor等
    inject code into a class at compile time

    Java Compilation:
        .java --> Parse and Enter <--> Annotation Processing --> Analyse and Generate
            --> .class

    hooks itself into the compilation process as an annotation processor
    Normally, annotation processors only generate new source files whereas Lombok modifies existing classes.
    The annotation processing API doesn't provide a mechanism for changing the AST of a class. The clever people at Project Lombok got around this through some unpublished APIs of javac.
    using back-door APIs

    @Data: All together now: A shortcut for @ToString, @EqualsAndHashCode, @Getter on all fields, and @Setter on all non-final fields, and @RequiredArgsConstructor!
    @Builder can generate so-called 'singular' methods for collection parameters/fields. These take 1 element instead of an entire list, and add the element to the list.
        比如Person.builder().name("Adam Savage").city("San Francisco").job("Mythbusters").job("Unchained Reaction").build();

Logging Frameworks
    actual: Log4J, JUL, LogBack(kind of Log4J2.0)
    facade: JCL(Spring uses it), SLF4J(Hibernate have changed to)

一个singleton的Bean：可以称为无状态的命名空间，包含一系列的函数
Spring
    p-namespace/c-namespace

    bean初始化的顺序可通过depends-on做

    Core Container
        Core, Bean, Context, SpEL

    Spring Configuration Metadata
        XML based configuration file.
        Annotation-based configuration
        Java-based configuration

    dependency injection
        Constructor-based
        Setter-based
        but it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies.

    AOP
        Aspect: an aspect is scattered or tangled as code, making it harder to understand and maintain
        Join point: This represents a point in your application where you can plug-in AOP aspect
        Advice: This is actual piece of code that is invoked during program execution by Spring AOP framework.
            Before/After/After-returning/After-throwing/Around
        PointCut: This is a set of one or more joinpoints where an advice should be executed.
        Introduction: An introduction allows you to add new methods or attributes to existing classes.
        Target object: The object being advised by one or more aspects, this object will always be a proxied object. Also referred to as the advised object.
        Weaving: Weaving is the process of linking aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or at runtime.

    The Spring Web model-view-controller (MVC) framework is designed around a DispatcherServlet that handles all the HTTP requests and responses.
        request-driven

    +------------------------------------------------------------------+
    | Annotation | Meaning                                             |
    +------------+-----------------------------------------------------+
    | @Component | generic stereotype for any Spring-managed component |
    | @Repository| stereotype for persistence layer                    |
    | @Service   | stereotype for service layer                        |
    | @Controller| stereotype for presentation layer (spring-mvc)      |
    +------------------------------------------------------------------+

    @Component  – Indicates a auto scan component.
    @Repository – Indicates DAO component in the persistence layer.
    @Service    – Indicates a Service component in the business layer.
    @Controller – Indicates a controller component in the presentation layer.
    @RequestMapping处理什么样的请求

    Autowired
        No qualifying bean of type […] found for dependency这种情况为对应的bean没注册
            如果是在Configuration中，需要添加对应方法返回该bean
        No qualifying bean of type […] is defined有多个Bean接口的实现
            异常为NoUniqueBeanDefinitionException
        No Bean Named […] is defined这种bean没定义

    AnnotationConfigApplicationContext可以注册一系列标记的类，如@Configuration
        使用register必须refresh
    WebApplicationContext: a spring container包含应用中的所有业务bean
        可以使用ContextLoaderListener 配置
        WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);
    添加<context:property-placeholder .. />后，可以使用variable substitution
        这块底层是如何执行的，值从哪儿搜索，被搜索对象何时创建的
    使用DispatcherServlet一般是将所有请求转到这个servlet，使用mvc:default-servlet-handler
        可将static resource转到default servlet上

    @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions.同样被@Component标记过，因此可被扫描
    @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context.
    @Import annotation allows for loading @Bean definitions from another configuration class.
    @Scope 指定bean的scope，默认为singleton，prototype为每次都重新申请，其他的还有
        request，session，globalsession
        singleton为per ApplicationContext，application为per ServletContext
    @Autowired annotation can apply to bean property setter methods, non-setter methods, constructor and properties.
    @Async标记某个方法异步执行，会有线程数控制么？
    @Qualifier当有多个想同类型的bean，要想使用autowire可配置该标记，值为beanid

    @Bean跟@Configuration在一块用表示某函数会返回一个让Spring管理的bean
        而跟@Component在一块时？？
        full mode VS lite mode
    @Configuration在启动时通过CGLIB被sub-class

    meta-annotation可以标记其他标记的标记，比如@Service实际上被标记了@Component
        因此可以说@Component为meta-annotation

    Spring Integration

    ApplicationContext本身可作为ResourceLoader
        传给它的参数默认会按照context的类型创建对应的Resource，但可以指定prefix
        来覆盖默认行为，如：classpath:/file:/http:

    Environment负责profiles和properties
        对于Properties通过一系列的PropertySource来进行
        默认的StandardEnvironment包含两个PropertySource，一个是JVM系统属性(
            System.getProperties())，一个是系统环境变量(System.getEnv())
            前者优先级更高
        配置中${xxx}都是从Environment中获取的

    Extensible XML authoring
        Authoring an XML schema
        NamespaceHandler
        BeanDefinitionParser
        Registering the above artifacts with Spring
            META-INF/spring.handlers
            META-INF/spring.schemas
        spring会搜索classpath自动发现新的扩展:DefaultNamespaceHandlerResolver

    controller方法返回callable可以异步处理请求，container-thread-A返回callable后结束
        处理由另外的线程进行，之后由container-thread-B返回结果
        use case: 请求要求结果且需要时间来计算结果，为避免用光container的线程池，提高吞吐
        内部使用request.startAsync()(servlet 3提供该功能)

    对于singleton的bean(默认都是), 且不是lazy init(默认)，那么当context启动后就会创建
    由于上面的一点，可以使用@PostConstruct来执行一些特定代码，也可以用属性init-method
        相比起来，前者更方便

    Bean definition profiles根据环境配置bean,嵌套的beans配置需要放到后面
        可通过context-param: contextInitializerClasses来配置profile功能的初始化
        系统属性spring.profiles.active可用来配置哪个profile为active，也可编程设置

    Annotation injection is performed before XML injection, so it can be overrided.
    Annotation wiring需要在配置中开启

    PropertiesLoaderUtils读取property配置文件

    没有id/name的bean可以通过类型来获取/autowire，这时不能有多个class相同但都没id/name，会报错

    annotation本身并不会做什么，再XML中需要<context:annotation-config />才能让其起作用
    annotation标记的bean并不会自动成为bean，需要用上面描述的几种方法来生效
    context:component-scan从包里扫描bean
    mvc:message-converters似乎能将HTTP payload按配置转成特定对象，这需要主动调用
        HTTP Message Conversion
    Velocity and FreeMarker are two templating languages that can be used as view technologies within Spring MVC applications.
    spring的Interceptor跟servlet filter类似，但跟spring结合更好，一些操作可能更易完成

    BeanFactoryPostProcessor/BeanDefinitionRegistryPostProcessor注册后的Listener

    bean生命周期管理方式：
        InitializingBean/DisposableBean分别调用afterPropertiesseSet/destroy
        JSR250提供了PostConstruct和PreDestroy，这种方式不依赖Spring
            这种方式比前者优先级更高

Maven
    BOM: bill of materials 用来让多个同源的库有相同的版本号

    默认情况下放到resources目录中的文件会放到当前module的classpath中，即会拷贝到target/classes
    mvn设置jar的manifest文件使用maven-jar-plugin
    maven固定化了很大一部分，并提供依赖管理

    Idea将目录设置到classpath中，右键->Mark directory as->source root

    显示所有依赖项：mvn dependency:resolve

gradle
    gradle build -x test

protobuf
    使用grpc；protoc --plugin=protoc-gen-grpc-java=/home/ubuntu/code/grpc-java/compiler/build/exe/java_plugin/protoc-gen-grpc-java --grpc-java_out=. pingpong.proto

MyBatis:
    a Java persistence framework that couples objects with stored procedures or SQL statements using an XML descriptor or annotations.
    Unlike ORM frameworks, MyBatis does not map Java objects to database tables but Java methods to SQL statements.
    The SqlSession contains absolutely every method needed to execute SQL commands against the database.
    SqlSessionFactoryBuilder/SqlSessionFactory/SqlSession/Mapper instances
    select count(1) from ${}设置表名

    ${} string substitution，而#{}类似PreparedStatement中的'?'
        ${}不能直接引用某个变量，String不行，目前的做法是放到Map里引用对应key

    ScriptRunner用来执行数据库脚本

    提供TableNameHandler，可以通过逻辑表名映射到实际表名

    DataSourceContextHolder.setDataSourceSuffix似乎用来设置database名的suffix

    MapperScannerConfigurer自动搜索所有的DAO
    SqlSessionFactoryBean设定typeAliasesPackage可自动搜索Entity

PowerMock/Mockito:
    Mock系统类(比如nio.file.Files)需要在@PrepareForTest中指定需要使用系统类的类，
        且添加@RunWith(PowerMockRunner.class)，普通的static类不需要
    PowerMockito.mockStatic来mock static类
    whenNew(Second.class).withNoArguments()可用mock constructor，但不推荐这么做
    可以verify某函数调用次数

    在when和verify部分，函数调用参数必须全部是matcher或全部是matcher，对于常量
        可以使用eq等函数将其转换成matcher

Java's ForkJoin Framework(JSR-166)
    ForkJoinPool: An instance of this class is used to run all your fork-join tasks
    RecursiveTask<V>: You run a subclass of this in a pool and have it return a result
    RecursiveAction: just like RecursiveTask except it does not return a result
    ForkJoinTask<V>: superclass of RecursiveTask<V> and RecursiveAction.

tomcat(any servlet container)
    查看servlet API版本：servlet-api.jar中META-INF/MANIFEST.MF
    应用可以目录结构存在，也可以为Web ARchive, or WAR file
        WEB-INF中存放应用相关数据classes/lib/web.xml

    $CATALINA_HOME/common/lib为应用与tomcat同享
    $CATALINA_BASE/shared/lib应用间共享
    /META-INF/context.xml: can be used to define Tomcat specific configuration options

    多实例运行时CATALINA_HOME为共享部分，CATALINA_BASE为各instance独立部分(比如conf)
    单实例两者相同

    部署：
        拷贝文件夹到$CATALINA_BASE/webapps/，此时context path即为子目录名
        拷贝WAR，启动时tomcat会解压war，更新时需要手动删除解压后的目录

    web.xml: Web Application Deployment Descriptor
        位置始终为application root/WEB-INF/web.xml
        display-name 显示在tomcat manager上
        distributable 表示应用可被用于distributed environment(主要是session相关)
        session-config - session-timeout指定HTTP session超时时间，单位分钟
        context-param 整个app的context参数，代码中可以按如下方式获取：
            String value = getServletContext().getInitParameter("webmaster");
        env-entryJNDI相关的配置参数
            // Get a handle to the JNDI environment naming context
            Context env = (Context)new InitialContext().lookup("java:comp/env");
            // Get a single value
            String webmasterEmail = (String)env.lookup("webmasterEmail");
        servlet除非InvokerServlet启用，否则只能通过servlet-mapping通过tomcat调用
        servlet-mapping需要定义在对应servlet后面，顺序很重要
        init-param给servlet或filter设置的参数
            String value = getServletConfig().getInitParameter("parameterName");
        load-on-startup设置servlet随应用启动加载，调用init()，数字越小优先级越高
        jsp-file映射到jsp而非某个servlet类
        filter在input/output都会调用，跟servlet类似需要配置filter-mapping
        listener，可监听的事件：context/session/session attribute相关

    container thread用于处理请求，Servlet 3支持异步处理

    在host前添加<Context path="" docBase="app_name"/>来设定ROOT应用

Servlet API:
    ServletContext:
        Defines a set of methods that a servlet uses to communicate with its servlet container, for example, to get the MIME type of a file, dispatch requests, or write to a log file.
        one context per "web application" per Java Virtual Machine

Camel:
    用来将Endpoint连起来
    CamelContext
        camel包含一个CamelContext，它包含一组Component
    Component
        A Component is essentially a factory of Endpoint instances.
        You can explicitly configure Component instances in Java code or an IoC container
        like Spring or Guice, or they can be auto-discovered using URIs.
    Endpoint
        An Endpoint acts rather like a URI or URL in a web application or a
        Destination in a JMS system;
        camel支持很多种endpoint，甚至ssh、servicenow等

        VM/SEDA: 异步内存seda队列，可见性不同
            uri format: seda:someName[?options]
        Direct: 同步
        Spring event: 同步，payload需要在SpringApplicationEvent中
    route中的多个bean/to会被当作pipeline
    Component is essentially a factory of Endpoint instances.

    Route中可访问的变量：
        ${header.<header_name>}: 可以使用setHeader，也可以通过sendBodyAndHeader
        ${body}

    EventNotifier当消息送到endpoint后收到通知

    从2.16开始支持dynamic to

Message Broker
    比如编译过程，从source code -- 抽象语法树 -- 中间输出 -- 磁盘输出
    这一过程展示的就是一个消息(数据)的表示和流向

    也可以用来模拟事件的发送

Kafka: Message Broker
    message -- topic
    producer -- Broker or Kafka Cluster -- Consumer

staged event-driven architecture(SEDA)
    decomposes a complex, event-driven application into a set of stages connected by queues.
    decouples event and thread scheduling from application logic.

FreeMarker
     a template engine: a Java library to generate text output (HTML web pages, e-mails,
     configuration files, source code, etc.) based on templates and changing data.

Enterprise Integration Patterns EIP

Enterprise application integration:
    is the process of linking such applications within a single organization together in order to simplify and automate business processes to the greatest extent possible, while at the same time avoiding having to make sweeping changes to the existing applications or data structures. Applications can be linked either at the back-end via APIs or (seldomly) the front-end (GUI).

JNDI enables a Java program or JSP page to reference resources specified in or outside the application.

Application Server(Java EE Container) VS Servlet Container(Web Container)
    A servlet-container supports only the servlet API (including JSP, JSTL).

    An application server supports the whole JavaEE - EJB, JMS, CDI, JTA, the servlet API (including JSP, JSTL), etc.

    It is possible to run most of the JavaEE technologies on a servlet-container, but you have to install a standalone implementation of the particular technology.

Middleware
    Middleware is computer software that provides services to software applications beyond those available from the operating system. It can be described as "software glue"

inversion of control (IoC)
    a design principle in which custom-written portions of a computer program receive the flow of control from a generic framework as compared to traditional procedural programming
UML
    关联关系
        被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为
        被关联类B的全局变量

shcedular->jobs->tasks


MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as DATETIME.)

看一下idea console输出是谁打印出来的

获取一个月前的timestamp和date时间：
    h2
        DATEADD('day', -29, CURRENT_DATE())
        datediff('ms', '1969-12-01', now()) 没有直接获得timestamp的方法
    mysql
        DATE_ADD(CURDATE(), INTERVAL -29 DAY)
        1000 * (UNIX_TIMESTAMP() - 31*24*60*60)



SimpleDateFormat可以安装某种格式格式化Date

用idea修改了代码，直接debug不一定会重新编译接口，需要手动重新build


ant的语法跟makefile类似，源，目的，操作，参数都需要自己指定


Java Management Extensions (JMX)
Java Message Service（JMS）

jdb
    trace go methods <thread-id>

每个被启动的java 应用都有一个Runtime对象（单例），包含一些系统函数
实现Runnable接口，通过Thread.run来运行
Timer用来调度作业的facility
Throwable是所有错误和异常的父类
ThreadFactory线程工程接口
AtomicInteger字面含义
Executors实际是个factory类
PlatformManagedObject：A platform managed object is a JMX MXBean for monitoring and managing a component in the Java platform.
ThreadMXBean：管理线程相关，获取CPU，Contention monitoring， 死锁检测等
    java.lang.management
    com.sun.management这两个都有
    loadInternalMonitors
GarbageCollectorMXBean The management interface for the garbage collection
ThreadPoolExecutor如字面意思
TimeUnit跟时间单位相关
ConcurrentHashMap允许并发操作
Solr（读作“solar”）是Apache Lucene项目的开源企业搜索（英语：Enterprise search）平台
ResultSetMetaData:An object that can be used to get information about the types and properties of the columns in a ResultSet object.
AtomicReference让其他类型对象atomic
java.sql.Connection:字面含义
ServiceLoader
    service为对应接口或抽象类
    service provider为service的具体实现
    在META-INF/services中添加名称为service全名的配置文件，里面包含具体的provider
        可通过该类的load来加载对应service
    service需要有无参constructor
Collection: root interface in the collection hierarchy



SELECT USER(); select database();查询当前信息。或者使用status


表相关的信息可从该表查询information_schema.tables

MyISAM的表可从information_schema.tables获取行数和表大小
    或select count(1), 两者行号都在表的.MYD文件中
InnoDB不行

SHOW TABLE STATUS查看某个表使用的什么数据引擎
    也可以用show create table
    在MyISAM下table_row, data_length, index_length为正确指，在Innodb下为内存索引大小近似
    结果从INFORMATION_SCHEMA TABLES来

show procedure status;
show columns in xxx.xxx;
drop procedure xxx;

select SQL_NO_CACHE * from可以不用mysql已缓冲的结果

group by的列需要在select部分体现

select count(*)/count(1)  count(name)稍慢些，事件线性增长
|  2097152  0.36 sec
|  4194304  0.71 sec
|  8388608  1.54 sec
| 16777216  3.09 sec

获得表大小的方式在innodb上可靠么？？
select table_name, table_rows, data_length/1024/1024 "table size(MB)" from information_schema.tables where table_schema="test" and table_name="test_count";

生成测试数据（加倍）
DELIMITER $$
CREATE PROCEDURE insert_test_data(in count int)
BEGIN
  DECLARE i INT DEFAULT 0;

  WHILE i < count DO
    INSERT INTO test.test_count  SELECT name FROM test.test_count;
    SET i = i + 1;
  END WHILE;
END$$
DELIMITER ;
CALL insert_test_data();
DROP PROCEDURE insert_test_data;



数据库配置文件由db.config.path给定，在ModuleDataSource中使用
    SpringContextInitializer会加载app.properties

db-context.xml包含表--DataSource的对应关系


Maven compiler plugin 3.0有bug，使用3.1
显示某个plugin的参数信息：mvn help:describe -Dplugin=war -Dfull=true
mvn protobuf:compile  可以执行单个goal
    goal的参数可以在plugin这一层配置configuration，如果再在execution这一层配置
        的configuration不生效
maven的lifecycle： https://maven.apache.org/ref/3.3.9/maven-core/lifecycles.html
在maven的settings.xml配置中，更改mirror，修改repository地址：
    http://maven.oschina.net/content/groups/public/

idea中被excluded的目录是不能设置为generated-root的，要先去掉excluded
maven有很多phase
    Maven Default Lifecycle Phases
    validate
    generate-sources
    process-sources
    generate-resources
    process-resources
    compile
    process-classes
    generate-test-sources
    process-test-sources
    generate-test-resources
    process-test-resources
    test-compile
    test
    prepare-package (maven 2.1+)
    package
    pre-integration-test
    integration-test
    post-integration-test
    verify
    install
    deploy

logback:
    每个logger都有自己的level，未设置就取parent的level，root的默认level为debug
    继承hierarchy通过'.'区分
    LoggerFactory.getLogger对同一个名称（类）始终返回同一个logger
    log过程是参数构建在前，判断在后，可用isXXXEnabled提高效率


Plumbr
    内存检测工具，JVMTI写的
    https://www.javacodegeeks.com/2014/03/migrating-from-javaagent-to-jvmti-our-experience.html

java世界里编译出的是字节码，有很多技术是会修改字节码的，比如代码混淆，
    有时候代码混淆会把字符串一并更改掉，如果这时候出了一个很奇怪的问题，可以
    看一下字节码：比如String.startsWith函数总是得不到正确的结果，而该函数肯定
    没有问题，可以看一下字节码是不是有部分内容被改掉了

javaagent的premain是可以下断点的，使用jpda，设置suspend=y，并且需要将jpda参数放到
    javaagent的前面，这样就可以在premain下断点了

查看java的当前配置项：java -XX:+PrintFlagsFinal -version
java工具
    jhat - Java Heap Analysis Tool
    javap - Java class file disassembler(p in javap means printer)
    jconsole - J2SE Monitoring and Management Console
    jinfo - configuration info
    jstack - 基本上等于kill -3, 可以dump远程进程
    jmap - prints shared object memory maps or heap memory details
    jsadebugd - serviceability agent debug daemon
    jstat - Java Virtual Machine statistics monitoring tool
        -gc 可以查看所有区块内存的使用情况
        -gccapacity 查看使用量和最大最小配置
    jvisualvm - profile and monitor tool
    jcmd
    java -XX:+PrintFlagsFinal -version

proxy pattern:
    Allows for object level access control by acting as a pass through entity
    or a placeholder object.

    An access proxy is used to enforce a security policy on access to a service or data-providing object.
    A facade is a single interface to multiple underlying objects.
    The remote proxy is used to mask or shield the client object from the fact that the underlying object is remote.
    A virtual proxy is used to perform lazy or just-in-time instantiation of the real object.

    Java proxies are runtime implementations of interfaces. On other cases
        use CGLib

高编译低运行只能保证字节码兼容，不保证类库兼容
    比如：ConcurrentHashMap.keySet()如果再1.8编译会返回KeySetView，该类在1.7上没有
    因此最好的保持binary兼容的方法仍然是，想支持什么最低版本，就在什么版本上编译

压缩效率/压缩大小
    压缩算法，算法参数
    针对数据量本身的处理，如id--string的转换，使用map存储所有字符串

影响问题复现的原因
    时间
    启动时序
    机器/os

java options:
    -Xms -Xmx
    -XX:+PrintCommandLineFlags打印默认gc

GC：hotspot基本上都是stop-the-world
    方法：
        GarbageCollectorMXBean获取的汇总信息
        -XX:+PrintGCDetails等debug参数，输出到控制台
        Java7u4后的通知机制
        JVMTI
    GarbageCollectionFinish只在full gc才会通知

GC介绍
http://www.fasterj.com/articles/oraclecollectors1.shtml
http://stackoverflow.com/questions/2129044/java-heap-terminology-young-old-and-permanent-generations
https://github.com/HeapStats/heapstats

Java Management Extension (JMX) is a standard technology that has been part of the JVM since Java 5. It makes it possible to manage and monitor Java applications and system resources. Resources are represented as so-called MBeans (Managed Beans).

重命名类和包：Jar Jar Links

OOM的description
    Java heap space
    unable to create new native thread
    GC overhead limit exceeded
    PermGen space
        java8里叫MetaData
    Requested array size exceeds VM limit

JVMTI
    JVM TI interface pointer is called the environment pointer可以有多个，有各自的设置
    JNI自动管理sixteen local references以内的自动释放，超了需要自己释放
    JNI函数使用error code和exception提示异常信息，需要native代码处理出现的Exception
    Agent_OnLoad
        options仅在该函数域内可用
        非0返回会导致VM退出
    VM execute phase
        OnLoad
        primordial
        start
        Live(VMInit后）
        dead
    jvmti agent会被作为JNI native搜索对象，在其他的之后，可用NativeMethodBind event捕获


Hotspot
    CallbackWrapper的析构函数会设置tag的变更，因此FollowReference能够修改tag
        类似在函数头创建一个对象，constructor枷锁，deconstructor释放锁，这样分支代码
        就简洁多了
    "oop", or ordinary object pointer
    Compressed oops
        enabled by default in Java SE 6u23 and later. In Java SE 7, use of compressed oops is the default for 64-bit JVM processes when -Xmx isn't specified and for values of -Xmx less than 32 gigabytes. For JDK 6 before the 6u23 release, use the -XX:+UseCompressedOops flag with the java command to enable the feature.
        倒不是为节约内存，而是节省cache和bus占用，让更多obj命中，提高效率
        记录obj-id，最多2^32个，转换公式：base + obj-id * sizeof(char *)
    Zero-Based Compressed Ordinary Object Pointers (oops)：
        如果操作系统支持从0 reserve虚存，就不需要base了
        Solaris, Linux, and Windows 都支持

JVM
    上面是栈顶
    +--------+----------+----------+---------+-----------+----------+
    |  DUP   |  DUP_X1  |  DUP_X2  |  DUP2   |  DUP2_X1  |  DUP2_X2 |
    +--------+----------+----------+---------+-----------+----------+
    | |A A|  |  |A A|   |  |A  A|  |  |A A|  |   |A A|   |   |A A|  |
    |    A   |  |B B|   |  |B  B|  |  |B B|  |   |B B|   |   |B B|  |
    |        |     A    |  |C  C|  |     A   |   |C C|   |   |C C|  |
    |        |          |      A   |     B   |      A    |   |D D|  |
    |        |          |          |         |      B    |      A   |
    |        |          |          |         |           |      B   |
    +--------+----------+----------+---------+-----------+----------+

java逆向
    对于混淆代码，可以先把field等改成长名字，避免跟方法/类混淆，减少理解难度

binary name   use '.'
internal form of binary name, use '/'
descriptor(只针对field和method)
signature

servlet不是线程安全的，在servlet中使用示例变量存放信息会导致同步问题


打开JMX
-Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi
.server.hostname=10.128.6.238

classloader的verification过程好像要求自己需要的类一定要在自己的classloader层次里能找到？？

sun.boot.class.path
java.ext.dirs


Serviceability Agent(sa)
    $JAVA_HOME/lib/sa-jdi.jar
    sun.jvm.hotspot.tools.jcore.ClassDump包含main可dump所有的类
        -Dsun.jvm.hotspot.tools.jcore.filter可指定filter只dump特定的类，filter
        需要实现ClassFilter接口

执行jar包时，只能通过manifest指定cp，命令行不起作用

MemoryMapped mmap的java接口，可用来做IPC

java memory keywords:
    Heap Memory
    Non Direct ByteBuffer
    Direct ByteBuffer（may or may not use mmap)
    Off Heap or Direct Memory

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".

jar cvf program.jar -C path/to/classes .

What is a Java Safepoint?找时间把后两个看完
    http://chriskirk.blogspot.jp/2013/09/what-is-java-safepoint.html
    http://psy-lob-saw.blogspot.jp/2015/12/safepoints.html
    http://psy-lob-saw.blogspot.jp/2016/02/why-most-sampling-java-profilers-are.html

transient 的对象不会被序列化
对敏感字段加密
情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。
解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。


Tiered Compilation
Compressed Oops
Zero-Based Compressed Ordinary Object Pointers (oops)
Escape Analysis
Escape analysis is a technique by which the Java Hotspot Server Compiler can analyze the scope of a new object's uses and decide whether to allocate it on the Java heap.

The HotSpot™ Serviceability Agent: An out-of-process high level debugger for a Java™ virtual machine

java.lang.OutOfMemoryError: unable to create new native thread
以下结果在64b机器上测试，hotspot 1.7.0_79-b15
    如果以root运行，jvm会自动调整ulimit，此时通过ulimit限制线程数/内存占用无效
    jvm本身会创建10几个（本机数量）native thread，因此可用数量要减去该部分
    virtual memory/physical memory/max user processes/stack size(本机1M)都会影响实际可创建的线程数量
    -Xms或者当前正在使用的heap大小也会影响，因为heap内存需要pin(lock)到内存中
    以下内核参数也会影响实际可创建线程数
        sys.kernel.threads-max 全局单进程最大线程数，对应路径/proc/sys/kernel/threads-max。/etc/sysctl.conf做永久修改
        sys.kernel.pid_max tid最大编号
        sys.vm.max_map_count 至少为2倍thread-count，否则会报Attempt to protect stack guard pages failed
