#############################################################
# C
#############################################################
libc中提供backtrace*方法，可访问当前函数栈信息（在程序中直接得到）
在windows下可使用CaptureStackBackTrace或者StackWalk*来访问.
    使用gcc编译除了要加-g -ggdb外，还要添加-rdynamic使ld将所有符号都添加到动态符号表中
    此外还可以使用addr2line将函数地址转成函数名，或libunwind

snprintf会自动加null字符

LIBRARY_PATH 链接时, LD_LIBRARY_PATH 运行时

提高程序的可移植性:
    完全静态链接libc libc++可避免出现GLIBC_2.14 not found等错误
        -static-libgcc -static-libstdc++ -static
        -static 和 -ldl是冲突的，但是gcc允许同时指定，只有-static有效
    静态链接不是最好的支持程序可移植的方式, 见下
        http://people.redhat.com/~drepper/no_static_linking.html
    较好的方式是获得另一个libc/c++库, 连接时使用-L(或LIBRARY_PATH,但在64上编32位程序时失效,估计跟gcc默认设置有关)指定过去
        (或者使用--sysroot, 测试发现我的系统不管用)
    或者在一个支持的最底版本系统上编译(chroot, docker等)
直接运行/lib/libc.so.6可查看其信息


编译C程序，如果函数没声明就使用，编译器会设置默认返回int，在32位环境下没问题，在64位环境下可能会导致严重错误
    比如返回一个64位指针，则会被强转成32位int，导致错误
    所以在编译程序时，要特别注意警告，最好设置成存在警告则编译失败
    -Werror-implicit-function-declaration
    -Werror使所有警告变成错误

gcc会按命令行从左往右的顺序扫描符号，使用gcc编译程序时一定注意链接库指定顺序，否则可能出现明明指定了正确的库，但是仍然报找不到符号的问题。

glibc编译后libpthread.so 和libc.so 都是脚本，里面指定实际库所在绝对位置，如果更改了位置需要进行修改
    上面的问题可能出现加了-L,但是ld找的库却在另一个目录的情况,导致链接失败

do while(false)可以方便的break（类似goto的效果）

gcc -s strip掉符号表
查看gcc默认的include路径
gcc -xc -E -v -
gcc -xc++ -E -v -
gcc 中 -Wl向ld传参数, 比如-Wl,--verbose查看链接使用的库路径及详细检索过程
gcc -print-search-dirs | sed 's/:/\n/g' 查看默认库及头文件搜索路径
gcc -dumpspecs可查看默认的flag等信息, -specs指定使用的specs
ldd -v 可显示所依赖的库版本

makefile里直接调用make不会继承当前的参数比如-f，导致奇怪的结果


#############################################################
# GDB
#############################################################
list
break/delete/info break
info
run/attach/kill/continue
next/step
print
bt/where
set/show args
cd/pwd
info program
display
watch
call
layout src.
quit
info threads
thread
frame
print mutex可查看那个线程拥有mutex
kill
--pid  attch进程
gdb调动态库，设置函数断点后会提示你加载动态库，适合调使用dlopen打开的动态库（不能用list打印）
break 403
commands
silent
set x = y + 4
cont
end

x系统学习下gdb
