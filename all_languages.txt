#############################################################
# C
#############################################################
libc中提供backtrace*方法，可访问当前函数栈信息（在程序中直接得到）
在windows下可使用CaptureStackBackTrace或者StackWalk*来访问.
    使用gcc编译除了要加-g -ggdb外，还要添加-rdynamic使ld将所有符号都添加到动态符号表中
    此外还可以使用addr2line将函数地址转成函数名，或libunwind

snprintf会自动加null字符

LIBRARY_PATH 链接时, LD_LIBRARY_PATH 运行时

提高程序的可移植性:
    完全静态链接libc libc++可避免出现GLIBC_2.14 not found等错误
        -static-libgcc -static-libstdc++ -static
        -static 和 -ldl是冲突的，但是gcc允许同时指定，只有-static有效
    静态链接不是最好的支持程序可移植的方式, 见下
        http://people.redhat.com/~drepper/no_static_linking.html
    较好的方式是获得另一个libc/c++库, 连接时使用-L(或LIBRARY_PATH,但在64上编32位程序时失效,估计跟gcc默认设置有关)指定过去
        (或者使用--sysroot, 测试发现我的系统不管用)
    或者在一个支持的最底版本系统上编译(chroot, docker等)
直接运行/lib/libc.so.6可查看其信息


编译C程序，如果函数没声明就使用，编译器会设置默认返回int，在32位环境下没问题，在64位环境下可能会导致严重错误
    比如返回一个64位指针，则会被强转成32位int，导致错误
    所以在编译程序时，要特别注意警告，最好设置成存在警告则编译失败
    -Werror-implicit-function-declaration
    -Werror使所有警告变成错误

gcc会按命令行从左往右的顺序扫描符号，使用gcc编译程序时一定注意链接库指定顺序，否则可能出现明明指定了正确的库，但是仍然报找不到符号的问题。

glibc编译后libpthread.so 和libc.so 都是脚本，里面指定实际库所在绝对位置，如果更改了位置需要进行修改
    上面的问题可能出现加了-L,但是ld找的库却在另一个目录的情况,导致链接失败

do while(false)可以方便的break（类似goto的效果）

gcc -s strip掉符号表
查看gcc默认的include路径
gcc -xc -E -v -
gcc -xc++ -E -v -
gcc 中 -Wl向ld传参数, 比如-Wl,--verbose查看链接使用的库路径及详细检索过程
gcc -print-search-dirs | sed 's/:/\n/g' 查看默认库及头文件搜索路径
gcc -dumpspecs可查看默认的flag等信息, -specs指定使用的specs
ldd -v 可显示所依赖的库版本

gcc4.1.2(CentOS 5.5)要使用PTHREAD_MUTEX_ERRORCHECK需-D_GNU_SOURCE

makefile里直接调用make不会继承当前的参数比如-f，导致奇怪的结果 ${MFLAGS}为传入的参数

read/write读取socket，返回0表示对方关闭连接

linux栈溢出不报错，如果访问相关地址则会导致SIGSEGV

如果修改了头文件中结构体信息比如将某指针换成值，而makefile又没将头文件作为依赖
这时某些已经编译过的源文件就不会再编译，也会链接成功，但执行时会出现很奇怪的段错误
（比如指向同一地址的两个指针再gdb中打印出不同的结果）

#############################################################
# GDB
#############################################################
list/list -
break/delete/info break
info
run/attach/kill/continue
next/step
print/set print elements 0 设置gdb的打印元素上限，0为不限制
printf "%s\n", some_string 不escape打印
bt/where
set/show args
cd/pwd
info program
display
watch
call
layout src.
info threads/thread/frame
print mutex可查看那个线程拥有mutex
使用valgrind和gdb一起查mem leak
call可直接调用函数
--pid  attch进程
set follow-fork-mode <mode> 调试child/parent
gdb调动态库，设置函数断点后会提示你加载动态库，适合调使用dlopen打开的动态库（不能用list打印）
break 403
commands
silent
set x = y + 4
cont
end

x系统学习下gdb

#############################################################
# SED
#############################################################
s/p/n/d/q//N/D/P/w/r/a/i/c/=/y/l/x/h/H/g/G/:/b/t/;/

注意shell会首先做处理，\意味着一条命令被断行
sed '\
s/ /\\\\
/' file

Using & as the matched string
If the expression starts with a backslash, the next character is the delimiter
sed '\,^#, s/[0-9][0-9]*//'
You can specify a range on line numbers by inserting a comma between the numbers
sed '101,$ s/A/a/'
命令前可加！将其语义去反（比如p为匹配时打印，！p为不匹配时打印）
the "!" command "inverts" the address range, operating on the other lines. 可用来做if else的逻辑
The curly braces, "{" and "}," are used to group the commands.
{}作为一个整体可取！，并可嵌套
sed -n '
	1,100 {
		/begin/,/end/ {
		     s/#.*//
		     s/[ ^I]*$//
		     /^$/ d
		     p
		}
	}
'
If you did not want to make any changes where the word "begin" occurred, you could simple add a new condition to skip over that line:

#!/bin/sh
sed '
	/begin/,/end/ {
	    /begin/n # skip over the line that has "begin" on it
	    s/old/new/
	}
'
However, skipping over the line that has "end" is trickier. If you use the same method you used for "begin" then the sed engine will not see the "end" to stop the range - it skips over that as well. The solution is to do a substitute on all lines that don't have the "end" by using

#!/bin/sh
sed '
    /begin/,/end/ {
      /begin/n # skip over the line that has "begin" on it
      /end/ !{
        s/old/new/
      }  
    }
'

Remember - only one space must follow the command. Anything else will be considered part of the file name. The "w" command also has the same limitation as the "w" flag: only 10 files can be opened in sed

The other subtlety is the "d" command deletes the current data in the pattern space. Once all of the data is deleted, it does make sense that no other action will be attempted. Therefore a "d" command executed in a curly brace also aborts all further actions. 

The main loop of a sed script looks like this:

The next line is read from the input file and places it in the pattern space. If the end of file is found, and if there are additional files to read, the current file is closed, the next file is opened, and the first line of the new file is placed into the pattern space.
The line count is incremented by one. Opening a new file does not reset this number.
Each sed command is examined. If there is a restriction placed on the command, and the current line in the pattern space meets that restriction, the command is executed. Some commands, like "n" or "d" cause sed to go to the top of the loop. The "q" command causes sed to stop. Otherwise the next command is examined.
After all of the commands are examined, the pattern space is output unless sed has the optional "-n" argument.

Since the "=" command only prints to standard output, you cannot print the line number on the same line as the pattern. You need to edit multi-line patterns to do this.

There is one more "location" to be covered: the hold buffer or hold space. Think of it as a spare pattern buffer.

The "b" command branches to the label. The label follows the command. If no label is there, branch to the end of the script. 

Normally, when you specify several files on the command line, sed concatenates the files into one stream, and then operates on that single stream. The '-s' command tells GNU sed to treat the files are independent files.

The -u Unbuffered argument

Normally - Unix and Linux systems apply some intelligence to handling standard output. It's assumed that if you are sending results to a terminal, you want the output as soon as it becomes available. However, if you are sending the output to a file, then it's assumed you want better performance, so it buffers the output until the buffer is full, and then the contents of the buffer is written to the file. Let me elaborate on this. Let's assume for this example you have a very large file, and you are using sed to search for a string, and to print it when it is found:

sed -n '/MATCH/p' <file
Since the output is the terminal, as soon as a match is found, it is printed. However, if sed pipes its output to another program, it will buffer the results. But there are times when you want immediate results. This is especially true when you are dealing with large files, or files that occasionally generate data. To summarize, you have lots of input data, and you want sed to process it, and then send this to another program that processes the results, but you want the results when it happens, and not delayed. Let me make up a simple example. It's contrived, but it does explain how this works. Here's a program called SlowText that prints numbers from 1 to 60, once a second:
#!/bin/sh
for i in `seq 1 60`
do
  echo $i
  sleep 1
done
Let's use sed to search for lines that have the character '1', and have it send results to awk, which will calculate the square of that number. This would be the admittedly contrived script:
SlowText | sed -n '/1/p' | awk '{print $1*$1}'
This works, but because sed is buffering the results, we have to wait until the buffer fills up, or until the SlowText program exists, before we the results. You can eliminate the buffering, and see the results as soon as SlowText outputs them, by using the "-u" option. With this option, you will see the squares printed as soon as possible:
SlowText | sed -un '/1/p' | awk '{print $1*$1}'
The long form of the argument is "--unbuffered".

GNU扩展-z，可使用NULL作为行分隔


可在sed命令前指定范围
    Specifying a line by its number.
    Specifying a range of lines by number.
    All lines containing a pattern.
    All lines from the beginning of a file to a regular expression
    All lines from a regular expression to the end of the file.
    All lines between two regular expressions.
命令后可指定flags(也同名命令一样）
    /I - Ignore Case
    /w - filename Write to a file with
    /g - Global replacement
    /p - print
