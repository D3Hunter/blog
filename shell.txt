shell中变量${var},加{}以分隔变量名，和$var一个意思
命令替换$(cmd)和符号`cmd`差不多

()和{}都是对一串的命令进行执行，但有所区别：
    A,()只是对一串命令重新开一个子shell进行执行
    B,{}对一串命令在当前shell执行
    C,()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开
    D,()最后一个命令可以不用分号
    E,{}最后一个命令要用分号
    F,{}的第一个命令和左括号之间必须要有一个空格
    G,()里的各命令不必和括号有空格
    H,()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令

A,${var:-string}：若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}
B,${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var：
C,${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)
D,${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。

POSIX标准的扩展计算:$((exp))
    这种计算是符合C语言的运算符，也就是说只要符合C的运算符都可用在$((exp))，甚至是三目运算符。
    注意：这种扩展计算是整数型的计算，不支持浮点型.若是逻辑判断，表达式exp为真则为1,假则为0。

四种模式匹配替换结构：${var%pattern},${var%%pattern},${var#pattern},${var##pattern}
    %|%%表示从最右边(即结尾)匹配的，#|##从最左边(即开头)匹配的
    #|%  是最短匹配
    ##|%%是最长匹配
    结构中的pattern支持通配符，*表示零个或多个任意字符，?表示零个或一个任意字符，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。

$$  Shell本身的PID（ProcessID） 
$!  Shell最后运行的后台Process的PID 
$?  最后运行的命令的结束代码（返回值） 
$-  使用Set命令设定的Flag一览 
$*  所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 
$@  所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 
$#  添加到Shell的参数个数 
$0  Shell本身的文件名 
$1～$n 位置变量

set  a b c 设置到位置变量中
set -x 类似与verbose

IFS(Internal Field Seprator) 会影响set设置位置变量，及echo是否使用”扩起来，比如$@ $*

cat多行导入
cat <<EOF 读入标准输入直到遇到EOF为止，可包含变量。也可不使用终止符,而用Ctrl-D
    j@j-System-Product-Name:~$ cat << EOF
    > ad
    > sd
    > EOF
    ad
    sd

: 是no-op,可接受参数

if中用-a -o 表示 AND OR

-bash: [: too many arguments  使用的变量被IFS拆分为多个参数 需要用双引号扩起来

