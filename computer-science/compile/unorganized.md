### concepts related to parser
concepts in scope: mathematics, computer science, linguistics and formal language theory
- `LL`: Left to right, performing Leftmost derivation
- An `LL parser` is called an `LL(k) parser` if it uses `k` tokens of lookahead when parsing a sentence. A grammar is called an `LL(k) grammar` if an `LL(k)` parser exists that can parse sentences belonging to the language that the grammar generates without backtracking.
- `a formal language` is a set of strings of symbols together with a set of rules that are specific to it. A formal language is often defined by means of a `formal grammar` such as a `regular grammar` or `context-free grammar`, also called its `formation rule`.
- `Well-formedness` is the quality of a clause, word, or other linguistic element that conforms to the grammar of the language of which it is a part. Well-formed words or phrases are grammatical, meaning they obey all relevant rules of grammar. In contrast, a form that violates some grammar rule is `ill-formed` and does not constitute part of the language.
- `formal language` consists of words whose letters are taken from an alphabet and are `well-formed` according to a specific set of rules.
- `grammar` (when the context is not given, often called a `formal grammar` for clarity) is a set of production rules for strings in a formal language.
- `context-free grammar (CFG)` is a certain type of formal grammar. In `context-free grammars`, all rules are one-to-one, one-to-many, or one-to-none. These rules can be applied regardless of context. The left-hand side of the production rule is always a `nonterminal` symbol. This means that the symbol does not appear in the resulting formal language.
- Languages generated by `context-free grammars` are known as `context-free languages (CFL)`. Different `context-free grammars` can generate the same `context-free language`. It is important to distinguish the properties of the language (`intrinsic properties`) from the properties of a particular grammar (`extrinsic properties`).
- `LALR parser` or `Look-Ahead LR parser` is a simplified version of a `canonical LR parser`.
- `canonical LR parser` or `LR(1) parser` is an `LR(k) parser` for `k = 1`, i.e. with a single lookahead terminal.
- `LR parsers` are a type of `bottom-up parser` that efficiently read `deterministic context-free languages`, in guaranteed `linear time`.
- A `sentential form` is any string derivable from the start symbol
- A `derivation` of a string for a grammar is a sequence of grammar rule applications that transform the start symbol into the string. A derivation proves that the string belongs to the grammar's language.
    - A `derivation` is fully determined by giving, for each step:
        - which non-terminal in the sentential form to apply a production rule to
        - which production rule for that non-terminal to apply
    - `top-down parse`是leftmost，`bottom-up parse`是`reverse rightmost derivation`
    - `Rightmost derivation` has very large memory requirements
    - `leftmost derivation` and `rightmost derivation`影响grammar中的代码执行顺序，需注意
- BNF(Backus–Naur form or Backus normal form) is a `metasyntax` notation for context-free grammars, often used to describe the syntax of languages used in computing.
- EBNF(extended Backus–Naur form) is a family of metasyntax notations, any of which can be used to express a context-free grammar. 可设置可选或重复production，任何EBNF都可转为BNF
- `Syntax-directed translation` refers to a method of compiler implementation where the source language translation is completely driven by the parser.
    - `Syntax-directed translation` fundamentally works by adding actions to the productions in a context-free grammar, resulting in a `Syntax-Directed Definition` (`SDD`).
- `SYNTAX-DIRECTED DEFINITION` is a context-free grammar in which each grammar symbol` X` is associated with two finite sets of values: the `synthesized attributes` of` X` and the `inherited attributes` of` X`, each production `A` is associated with a finite set of expressions called `semantic rules`.

Top-down parsers:
- easy to understand and easy to customize
- allows the use of more general grammars
- being easier to debug
- having the ability to parse to any non-terminal in the grammar
- having the ability to pass values (attributes) both up and down the parse tree during parsing.
- 无法处理左递归（在parse时就要决定当前要使用的production，极端情况下需要无限的lookahead才能确定，`ANTLR`的`ALL(*)`可处理）

bottom-up parsing
- 可处理左递归，右递归（直接shift）
- 难以诊断错误
- 不直观，使用起来不友好

LR
- shift: shift `item` into stack
- reduce: pop items on the stack and assembly them into larger one

- shift/reduce conflict
- reduce/reduce conflict: 使用哪个production

### parser classification
不同的文章概念表述略有差异
- Top-down Parser
    - `Recursive descent parser` or `Brute force parser` or `the with backtracking parser`. 具体实现上可以不用递归
    - `Non-recursive descent parser` or `LL(1) parser` or `predictive parser` or `without backtracking parser` or `dynamic parser`. 具体实现上可以用递归
        - `Predictive parsing` is possible only for the class of `LL(k)` grammars. 
        - 一般说的`LL parser`指的就是这种
        - 一般使用一个`Table`，根据当前`non-terminal`和`lookahead`确定目标`production`. 这是个优化方法，避免将其硬编码到parser，少量的grammar改动就导致大量parser代码改动，在`LR parser`中也常用到
        - 可使用`ANTLR`、`JavaCC`自动生成
- Bottom-up Parser (uses `reverse right most derivation`)
    - LR parser
        - `LR(0)`
        - `SLR(1)`
        - `LALR(1)`
        - `CLR(1)`
    - Operator precedence parser
        - 计算器使用该parser将中缀算数运算表达式转为`Reverse Polish notation (RPN)`形式
        - 包含`shunting yard`和`operator precedence climbing`

### common used languages
Most computer languages are "technically" not `LL` because they are not even context-free. That would include languages which require identifiers to be declared (C, C++, C#, Java, etc.). C++的预处理（也可把预处理跟语言分开）／模版等。因此 a common parsing strategy is to recognize a `superset` of a language, and then reject non-conforming programs through a subsequent analysis of the resulting parse tree.

`Java` and `Python` were both designed to be `LL(1)` "pseudo-parseable".

### concepts related to code optimization
- `peephole optimization` is a kind of optimization performed over a very small set of instructions in a segment of generated code. The set is called a "peephole" or a "window". It works by recognizing sets of instructions that can be replaced by shorter or faster sets of instructions.
- `basic block` is a straight-line code sequence with no branches in except to the entry and no branches out except at the exit. This restricted form makes a basic block highly amenable to analysis. Compilers usually decompose programs into their basic blocks as a first step in the analysis process. `Basic blocks` form the vertices or nodes in a control flow graph.
- `static single assignment` form (often abbreviated as SSA form or simply SSA) is a property of an intermediate representation (IR), which requires that each variable is assigned exactly once, and every variable is defined before it is used.
- `induction variable` is a variable that gets increased or decreased by a fixed amount on every iteration of a loop or is a linear function of another induction variable.

## language classification
[Comparison of parser generators](https://en.wikipedia.org/wiki/Comparison_of_parser_generators)
1. Regular languages
2. Deterministic context-free languages
3. Parsing expression grammars, deterministic boolean grammars
4. General context-free, conjunctive, or boolean languages
5. Context-sensitive grammars

`Chomsky hierarchy` (occasionally referred to as the Chomsky–Schützenberger hierarchy) is a containment hierarchy of classes of `formal grammars`.
- Type-0 Recursively enumerable
    - include all formal grammars. They generate exactly all languages that can be recognized by a Turing machine
- Type-1 Context-sensitive
- Type-2 Context-free
- Type-3 Regular(Regular languages)
    - `Regular expressions` describe `regular languages` in `formal language theory`. They have the same expressive power as `regular grammars`.

- The `deterministic context-free languages` are a proper subset of the `context-free languages` which can be efficiently parsed by `deterministic pushdown automata`. Many computer languages belong to this class of languages.
- `parsing expression grammar (PEG)`.
    - `PEGs` look similar to `context-free grammars (CFGs)`, but they have a different interpretation: the `choice` operator selects the first match in `PEG`, while it is ambiguous in `CFG`.
    - `PEG` use `scannerless parsers`: they do not need a separate lexer, or lexical analysis phase.
- `Conjunctive grammars` extend the basic type of grammars, the `context-free grammars`, with a `conjunction` operation.
- `boolean grammars`: extend the basic type of grammars, the `context-free grammars`, with `conjunction` and `negation` operations.
- `parser combinator` is a higher-order function that accepts several parsers as input and returns a new parser as its output.

